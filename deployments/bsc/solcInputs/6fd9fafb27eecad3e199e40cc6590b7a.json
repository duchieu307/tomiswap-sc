{
  "language": "Solidity",
  "sources": {
    "contracts/ballots/TomiBallot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport '../interfaces/IERC20.sol';\n\n/**\n * @title TomiBallot\n * @dev Implements voting process along with vote delegation\n */\ncontract TomiBallot {\n    struct Voter {\n        uint256 weight; // weight is accumulated by delegation\n        bool voted; // if true, that person already voted\n        address delegate; // person delegated to\n        uint256 vote; // index of the voted proposal\n    }\n\n    mapping(address => Voter) public voters;\n    mapping(uint256 => uint256) public proposals;\n\n    address public governor;\n    address public proposer;\n    uint256 public value;\n    uint256 public endBlockNumber;\n    bool public ended;\n    string public subject;\n    string public content;\n\n    uint256 private constant NONE = 0;\n    uint256 private constant YES = 1;\n    uint256 private constant NO = 2;\n\n    uint256 public total;\n    uint256 public createTime;\n\n    modifier onlyGovernor() {\n        require(msg.sender == governor, 'TomiBallot: FORBIDDEN');\n        _;\n    }\n\n    /**\n     * @dev Create a new ballot.\n     */\n    constructor(\n        address _proposer,\n        uint256 _value,\n        uint256 _endBlockNumber,\n        address _governor,\n        string memory _subject,\n        string memory _content\n    ) public {\n        proposer = _proposer;\n        value = _value;\n        endBlockNumber = _endBlockNumber;\n        governor = _governor;\n        subject = _subject;\n        content = _content;\n        proposals[YES] = 0;\n        proposals[NO] = 0;\n        createTime = block.timestamp;\n    }\n\n    /**\n     * @dev Give 'voter' the right to vote on this ballot.\n     * @param voter address of voter\n     */\n    function _giveRightToVote(address voter) private returns (Voter storage) {\n        require(block.number < endBlockNumber, 'Bollot is ended');\n        Voter storage sender = voters[voter];\n        require(!sender.voted, 'You already voted');\n        sender.weight += IERC20(governor).balanceOf(voter);\n        require(sender.weight != 0, 'Has no right to vote');\n        return sender;\n    }\n\n    /**\n     * @dev Delegate your vote to the voter 'to'.\n     * @param to address to which vote is delegated\n     */\n    function delegate(address to) public {\n        Voter storage sender = _giveRightToVote(msg.sender);\n        require(to != msg.sender, 'Self-delegation is disallowed');\n\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, 'Found loop in delegation');\n        }\n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote] += sender.weight;\n            total += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n            total += sender.weight;\n        }\n    }\n\n    /**\n     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.\n     * @param proposal index of proposal in the proposals array\n     */\n    function vote(uint256 proposal) public {\n        Voter storage sender = _giveRightToVote(msg.sender);\n        require(proposal == YES || proposal == NO, 'Only vote 1 or 2');\n        sender.voted = true;\n        sender.vote = proposal;\n        proposals[proposal] += sender.weight;\n        total += sender.weight;\n    }\n\n    /**\n     * @dev Computes the winning proposal taking all previous votes into account.\n     * @return winningProposal_ index of winning proposal in the proposals array\n     */\n    function winningProposal() public view returns (uint256) {\n        if (proposals[YES] > proposals[NO]) {\n            return YES;\n        } else if (proposals[YES] < proposals[NO]) {\n            return NO;\n        } else {\n            return NONE;\n        }\n    }\n\n    function result() public view returns (bool) {\n        uint256 winner = winningProposal();\n        if (winner == YES) {\n            return true;\n        }\n        return false;\n    }\n\n    function end() public onlyGovernor returns (bool) {\n        require(block.number >= endBlockNumber, 'ballot not yet ended');\n        require(!ended, 'end has already been called');\n        ended = true;\n        return result();\n    }\n\n    function weight(address user) external view returns (uint256) {\n        Voter memory voter = voters[user];\n        return voter.weight;\n    }\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}"
    },
    "contracts/ballots/TomiBallotFactory.sol": {
      "content": "pragma solidity >=0.6.6;\n\nimport \"./TomiBallot.sol\";\n\ncontract TomiBallotFactory {\n    event Created(address indexed proposer, address indexed ballotAddr, uint256 createTime);\n\n    constructor() public {}\n\n    function create(\n        address _proposer,\n        uint256 _value,\n        uint256 _endBlockNumber,\n        string calldata _subject,\n        string calldata _content\n    ) external returns (address) {\n        require(_value >= 0, 'TomiBallotFactory: INVALID_PARAMTERS');\n        address ballotAddr = address(\n            new TomiBallot(_proposer, _value, _endBlockNumber, msg.sender, _subject, _content)\n        );\n        emit Created(_proposer, ballotAddr, block.timestamp);\n        return ballotAddr;\n    }\n}\n"
    },
    "contracts/TomiTransferListener.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\nimport './modules/Ownable.sol';\nimport './interfaces/ITgas.sol';\nimport './interfaces/ITomiFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/ITomiPair.sol';\nimport './libraries/TomiSwapLibrary.sol';\nimport './libraries/SafeMath.sol';\n\ncontract TomiTransferListener is Ownable {\n    uint256 public version = 1;\n    address public TGAS;\n    address public PLATFORM;\n    address public WETH;\n    address public FACTORY;\n    address public admin;\n\n    mapping(address => uint) public pairWeights;\n\n    event Transfer(address indexed from, address indexed to, address indexed token, uint256 amount);\n    event WeightChanged(address indexed pair, uint weight);\n\n    function initialize(\n        address _TGAS,\n        address _FACTORY,\n        address _WETH,\n        address _PLATFORM,\n        address _admin\n    ) external onlyOwner {\n        require(\n            _TGAS != address(0) && _FACTORY != address(0) && _WETH != address(0) && _PLATFORM != address(0),\n            'TOMI TRANSFER LISTENER : INPUT ADDRESS IS ZERO'\n        );\n        TGAS = _TGAS;\n        FACTORY = _FACTORY;\n        WETH = _WETH;\n        PLATFORM = _PLATFORM;\n        admin = _admin;\n    }\n\n    function changeAdmin(address _admin) external onlyOwner {\n        admin = _admin;\n    }\n\n    function updateTGASImpl(address _newImpl) external onlyOwner {\n        ITgas(TGAS).upgradeImpl(_newImpl);\n    }\n\n    function updatePairPowers(address[] calldata _pairs, uint[] calldata _weights) external {\n        require(msg.sender == admin, 'TOMI TRANSFER LISTENER: ADMIN PERMISSION');\n        require(_pairs.length == _weights.length, \"TOMI TRANSFER LISTENER: INVALID PARAMS\");\n\n        for(uint i = 0;i < _weights.length;i++) {\n            pairWeights[_pairs[i]] = _weights[i];\n            _setProdutivity(_pairs[i]);\n            emit WeightChanged(_pairs[i], _weights[i]);\n        }\n    }\n\n\n    function _setProdutivity(address _pair) internal {\n        (uint256 lastProdutivity, ) = ITgas(TGAS).getProductivity(_pair);\n        address token0 = ITomiPair(_pair).token0();\n        address token1 = ITomiPair(_pair).token1();\n        (uint reserve0, uint reserve1, ) = ITomiPair(_pair).getReserves();\n        uint currentProdutivity = 0;\n        if(token0 == TGAS) {\n            currentProdutivity = reserve0 * pairWeights[_pair];\n        } else if(token1 == TGAS) {\n            currentProdutivity = reserve1 * pairWeights[_pair];\n        }\n\n        if(lastProdutivity != currentProdutivity) {\n            if(lastProdutivity > 0) {\n                ITgas(TGAS).decreaseProductivity(_pair, lastProdutivity);\n            } \n\n            if(currentProdutivity > 0) {\n                ITgas(TGAS).increaseProductivity(_pair, currentProdutivity);\n            }\n        }\n    }\n\n    function upgradeProdutivity(address fromPair, address toPair) external {\n        require(msg.sender == PLATFORM, 'TOMI TRANSFER LISTENER: PERMISSION');\n        (uint256 fromPairPower, ) = ITgas(TGAS).getProductivity(fromPair);\n        (uint256 toPairPower, ) = ITgas(TGAS).getProductivity(toPair);\n        if(fromPairPower > 0 && toPairPower == 0) {\n            ITgas(TGAS).decreaseProductivity(fromPair, fromPairPower);\n            ITgas(TGAS).increaseProductivity(toPair, fromPairPower);\n        }\n    }\n\n    function transferNotify(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) external returns (bool) {\n        require(msg.sender == PLATFORM, 'TOMI TRANSFER LISTENER: PERMISSION');\n        if(ITomiFactory(FACTORY).isPair(from) && token == TGAS) {\n            _setProdutivity(from);\n        }\n\n        if(ITomiFactory(FACTORY).isPair(to) && token == TGAS) {\n            _setProdutivity(to);\n        }\n\n        emit Transfer(from, to, token, amount);\n        return true;\n    }\n}"
    },
    "contracts/modules/Ownable.sol": {
      "content": "pragma solidity >=0.5.16;\n\ncontract Ownable {\n    address public owner;\n\n    event OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, 'Ownable: FORBIDDEN');\n        _;\n    }\n\n    function changeOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), 'Ownable: INVALID_ADDRESS');\n        emit OwnerChanged(owner, _newOwner);\n        owner = _newOwner;\n    }\n\n}"
    },
    "contracts/interfaces/ITgas.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface ITgas {\n    function amountPerBlock() external view returns (uint);\n    function changeInterestRatePerBlock(uint value) external returns (bool);\n    function getProductivity(address user) external view returns (uint, uint);\n    function increaseProductivity(address user, uint value) external returns (bool);\n    function decreaseProductivity(address user, uint value) external returns (bool);\n    function take() external view returns (uint);\n    function takeWithBlock() external view returns (uint, uint);\n    function mint() external returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function upgradeImpl(address _newImpl) external;\n    function upgradeGovernance(address _newGovernor) external;\n    function transfer(address to, uint value) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n}"
    },
    "contracts/interfaces/ITomiFactory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface ITomiFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function contractCodeHash() external view returns (bytes32);\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function isPair(address pair) external view returns (bool);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n    function playerPairs(address player, uint index) external view returns (address pair);\n    function getPlayerPairCount(address player) external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n    function addPlayerPair(address player, address _pair) external returns (bool);\n}"
    },
    "contracts/interfaces/ITomiPair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface ITomiPair {\n  \n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address) external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address from, address to, uint amount) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address tokenA, address tokenB, address platform, address tgas) external;\n    function swapFee(uint amount, address token, address to) external ;\n    function queryReward() external view returns (uint rewardAmount, uint blockNumber);\n    function mintReward() external returns (uint rewardAmount);\n    function getTGASReserve() external view returns (uint);\n}"
    },
    "contracts/libraries/TomiSwapLibrary.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport '../interfaces/ITomiPair.sol';\nimport '../interfaces/ITomiFactory.sol';\nimport \"./SafeMath.sol\";\n\nlibrary TomiSwapLibrary {\n    using SafeMath for uint;\n\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'TomiSwapLibrary: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'TomiSwapLibrary: ZERO_ADDRESS');\n    }\n\n    function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        bytes32 rawAddress = keccak256(\n        abi.encodePacked(\n            bytes1(0xff),\n            factory,\n            salt,\n            ITomiFactory(factory).contractCodeHash()\n            )\n        );\n        return address(bytes20(rawAddress << 96));\n    }\n\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = ITomiPair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    \n    function quoteEnhance(address factory, address tokenA, address tokenB, uint amountA) internal view returns(uint amountB) {\n        (uint reserveA, uint reserveB) = getReserves(factory, tokenA, tokenB);\n        return quote(amountA, reserveA, reserveB);\n    }\n\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'TomiSwapLibrary: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'TomiSwapLibrary: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'TomiSwapLibrary: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'TomiSwapLibrary: INSUFFICIENT_LIQUIDITY');\n        uint numerator = amountIn.mul(reserveOut);\n        uint denominator = reserveIn.add(amountIn);\n        amountOut = numerator / denominator;\n    }\n    \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'TomiSwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'TomiSwapLibrary: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut);\n        uint denominator = reserveOut.sub(amountOut);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/TomiPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.5.1;\n\nimport './modules/Ownable.sol';\nimport './libraries/TransferHelper.sol';\nimport './interfaces/ITgas.sol';\nimport './interfaces/ITomiPair.sol';\nimport './interfaces/ITomiFactory.sol';\nimport './interfaces/ITomiGovernance.sol';\nimport './libraries/SafeMath.sol';\nimport './libraries/ConfigNames.sol';\nimport './interfaces/ITomiConfig.sol';\n\ninterface ITomiPlatform {\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts) ;\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ncontract TomiPool is Ownable {\n\n    using SafeMath for uint;\n    address public TGAS;\n    address public FACTORY;\n    address public PLATFORM;\n    address public WETH;\n    address public CONFIG;\n    address public GOVERNANCE;\n    uint public totalReward;\n    \n    struct UserInfo {\n        uint rewardDebt; // Reward debt. \n        uint rewardEarn; // Reward earn and not minted\n    }\n    \n    event ClaimReward(address indexed user, address indexed pair, address indexed rewardToken, uint amountTGAS);\n    event AddReward(address indexed pair, uint amount);\n\n    mapping(address => mapping (address => UserInfo)) public users;\n    \n    mapping (address => uint) public pairAmountPerShare;\n    mapping (address => uint) public pairReward;\n    \n    function initialize(address _TGAS, address _WETH, address _FACTORY, address _PLATFORM, address _CONFIG, address _GOVERNANCE) external onlyOwner {\n        TGAS = _TGAS;\n        WETH = _WETH;\n        FACTORY = _FACTORY;\n        PLATFORM = _PLATFORM;\n        CONFIG = _CONFIG;\n        GOVERNANCE = _GOVERNANCE;\n    }\n    \n    function upgrade(address _newPool, address[] calldata _pairs) external onlyOwner {\n        ITgas(TGAS).approve(_newPool, totalReward);\n        for(uint i = 0;i < _pairs.length;i++) {\n            if(pairReward[_pairs[i]] > 0) {\n                TomiPool(_newPool).addReward(_pairs[i], pairReward[_pairs[i]]);\n                totalReward = totalReward.sub(pairReward[_pairs[i]]);\n                pairReward[_pairs[i]] = 0;\n            }\n        }\n    }\n    \n    function addRewardFromPlatform(address _pair, uint _amount) external {\n        require(msg.sender == PLATFORM, \"TOMI POOL: FORBIDDEN\");\n        uint balanceOf = ITgas(TGAS).balanceOf(address(this));\n        require(balanceOf.sub(totalReward) >= _amount, 'TOMI POOL: ADD_REWARD_EXCEED');\n        \n        uint rewardAmount = ITomiConfig(CONFIG).getConfigValue(ConfigNames.FEE_LP_REWARD_PERCENT).mul(_amount).div(10000);\n        _addReward(_pair, rewardAmount);\n        \n        uint remainAmount = _amount.sub(rewardAmount);\n        uint governanceAmount = ITomiConfig(CONFIG).getConfigValue(ConfigNames.FEE_GOVERNANCE_REWARD_PERCENT).mul(remainAmount).div(10000);\n        if(governanceAmount > 0) {\n            TransferHelper.safeTransfer(TGAS, GOVERNANCE, governanceAmount);\n            ITomiGovernance(GOVERNANCE).addReward(governanceAmount);\n        }\n        if(remainAmount.sub(governanceAmount) > 0) {\n            TransferHelper.safeTransfer(TGAS, address(0), remainAmount.sub(governanceAmount));\n        }\n        emit AddReward(_pair, rewardAmount);\n    }\n    \n    function addReward(address _pair, uint _amount) external {\n        TransferHelper.safeTransferFrom(TGAS, msg.sender, address(this), _amount);\n        \n        require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\n        _addReward(_pair, _amount);\n        \n        emit AddReward(_pair, _amount);\n    }\n    \n    function preProductivityChanged(address _pair, address _user) external {\n        require(msg.sender == PLATFORM, \"TOMI POOL: FORBIDDEN\");\n        _auditUser(_pair, _user);\n    }\n    \n    function postProductivityChanged(address _pair, address _user) external {\n        require(msg.sender == PLATFORM, \"TOMI POOL: FORBIDDEN\");\n        require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\n        \n        _updateDebt(_pair, _user);\n    }\n    \n    function _addReward(address _pair, uint _amount) internal {\n        pairReward[_pair] = pairReward[_pair].add(_amount);\n        uint totalProdutivity = ITomiPair(_pair).totalSupply();\n        if(totalProdutivity > 0) {\n            pairAmountPerShare[_pair] = pairAmountPerShare[_pair].add(_amount.mul(1e12).div(totalProdutivity));\n            totalReward = totalReward.add(_amount);\n        }\n    }\n    \n    function _auditUser(address _pair, address _user) internal {\n        require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\n    \n        uint balance = ITomiPair(_pair).balanceOf(_user);\n        uint accAmountPerShare = pairAmountPerShare[_pair];\n        UserInfo storage userInfo = users[_user][_pair];\n        uint pending = balance.mul(accAmountPerShare).div(1e12).sub(userInfo.rewardDebt);\n        userInfo.rewardEarn = userInfo.rewardEarn.add(pending);\n        userInfo.rewardDebt = balance.mul(accAmountPerShare).div(1e12);\n    }\n    \n    function _updateDebt(address _pair, address _user) internal {\n        uint balance = ITomiPair(_pair).balanceOf(_user);\n        uint accAmountPerShare = pairAmountPerShare[_pair];\n        users[_user][_pair].rewardDebt = balance.mul(accAmountPerShare).div(1e12);\n    }\n    \n    function claimReward(address _pair, address _rewardToken) external {\n        _auditUser(_pair, msg.sender);\n        UserInfo storage userInfo = users[msg.sender][_pair];\n        \n        uint amount = userInfo.rewardEarn;\n        pairReward[_pair] = pairReward[_pair].sub(amount);\n        totalReward = totalReward.sub(amount);\n        require(amount > 0, \"NOTHING TO MINT\");\n        \n        if(_rewardToken == TGAS) {\n            TransferHelper.safeTransfer(TGAS, msg.sender, amount);\n        } else if(_rewardToken == WETH) {\n            require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\n            ITgas(TGAS).approve(PLATFORM, amount);\n            address[] memory path = new address[](2);\n            path[0] = TGAS;\n            path[1] = WETH; \n            ITomiPlatform(PLATFORM).swapExactTokensForETH(amount, 0, path, msg.sender, block.timestamp + 1);\n        } else {\n            require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\n            ITgas(TGAS).approve(PLATFORM, amount);\n            address[] memory path = new address[](2);\n            path[0] = TGAS;\n            path[1] = _rewardToken;\n            ITomiPlatform(PLATFORM).swapExactTokensForTokens(amount, 0, path, msg.sender, block.timestamp + 1);\n        }\n        \n        userInfo.rewardEarn = 0;\n        emit ClaimReward(msg.sender, _pair, _rewardToken, amount);\n    }\n    \n    function queryReward(address _pair, address _user) external view returns(uint) {\n        require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\n        \n        UserInfo memory userInfo = users[msg.sender][_pair];\n        uint balance = ITomiPair(_pair).balanceOf(_user);\n        return balance.mul(pairAmountPerShare[_pair]).div(1e12).add(userInfo.rewardEarn).sub(userInfo.rewardDebt);\n    }\n}"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/interfaces/ITomiGovernance.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface ITomiGovernance {\n    function addPair(address _tokenA, address _tokenB) external returns (bool);\n    function addReward(uint _value) external returns (bool);\n}\n"
    },
    "contracts/libraries/ConfigNames.sol": {
      "content": "pragma solidity >=0.5.16;\n\nlibrary ConfigNames {\n    bytes32 public constant PRODUCE_TGAS_RATE = bytes32('PRODUCE_TGAS_RATE');\n    bytes32 public constant SWAP_FEE_PERCENT = bytes32('SWAP_FEE_PERCENT');\n    bytes32 public constant LIST_TGAS_AMOUNT = bytes32('LIST_TGAS_AMOUNT');\n    bytes32 public constant UNSTAKE_DURATION = bytes32('UNSTAKE_DURATION');\n    bytes32 public constant REMOVE_LIQUIDITY_DURATION = bytes32('REMOVE_LIQUIDITY_DURATION');\n    bytes32 public constant TOKEN_TO_TGAS_PAIR_MIN_PERCENT = bytes32('TOKEN_TO_TGAS_PAIR_MIN_PERCENT');\n    bytes32 public constant LIST_TOKEN_FAILURE_BURN_PRECENT = bytes32('LIST_TOKEN_FAILURE_BURN_PRECENT');\n    bytes32 public constant LIST_TOKEN_SUCCESS_BURN_PRECENT = bytes32('LIST_TOKEN_SUCCESS_BURN_PRECENT');\n    bytes32 public constant PROPOSAL_TGAS_AMOUNT = bytes32('PROPOSAL_TGAS_AMOUNT');\n    bytes32 public constant VOTE_DURATION = bytes32('VOTE_DURATION');\n    bytes32 public constant VOTE_REWARD_PERCENT = bytes32('VOTE_REWARD_PERCENT');\n    bytes32 public constant TOKEN_PENGDING_SWITCH = bytes32('TOKEN_PENGDING_SWITCH');\n    bytes32 public constant TOKEN_PENGDING_TIME = bytes32('TOKEN_PENGDING_TIME');\n    bytes32 public constant LIST_TOKEN_SWITCH = bytes32('LIST_TOKEN_SWITCH');\n    bytes32 public constant DEV_PRECENT = bytes32('DEV_PRECENT');\n    bytes32 public constant FEE_GOVERNANCE_REWARD_PERCENT = bytes32('FEE_GOVERNANCE_REWARD_PERCENT');\n    bytes32 public constant FEE_LP_REWARD_PERCENT = bytes32('FEE_LP_REWARD_PERCENT');\n    bytes32 public constant FEE_FUNDME_REWARD_PERCENT = bytes32('FEE_FUNDME_REWARD_PERCENT');\n    bytes32 public constant FEE_LOTTERY_REWARD_PERCENT = bytes32('FEE_LOTTERY_REWARD_PERCENT');\n}"
    },
    "contracts/interfaces/ITomiConfig.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface ITomiConfig {\n    function governor() external view returns (address);\n    function dev() external view returns (address);\n    function PERCENT_DENOMINATOR() external view returns (uint);\n    function getConfig(bytes32 _name) external view returns (uint minValue, uint maxValue, uint maxSpan, uint value, uint enable);\n    function getConfigValue(bytes32 _name) external view returns (uint);\n    function changeConfigValue(bytes32 _name, uint _value) external returns (bool);\n    function checkToken(address _token) external view returns(bool);\n    function checkPair(address tokenA, address tokenB) external view returns (bool);\n    function listToken(address _token) external returns (bool);\n    function getDefaultListTokens() external returns (address[] memory);\n    function platform() external view returns  (address);\n    function addToken(address _token) external returns (bool);\n}"
    },
    "contracts/TomiPlatform.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport './libraries/ConfigNames.sol';\nimport './libraries/SafeMath.sol';\nimport './libraries/TransferHelper.sol';\nimport './libraries/TomiSwapLibrary.sol';\nimport './interfaces/IWETH.sol';\nimport './interfaces/ITomiGovernance.sol';\nimport './interfaces/ITomiConfig.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/ITomiFactory.sol';\nimport './interfaces/ITomiPair.sol';\nimport './interfaces/ITomiPool.sol';\nimport './modules/Ownable.sol';\nimport './modules/ReentrancyGuard.sol';\nimport './interfaces/ITomiTransferListener.sol';\nimport './interfaces/ITokenRegistry.sol';\n\nimport \"hardhat/console.sol\";\n\ncontract TomiPlatform is Ownable {\n    uint256 public version = 1;\n    address public TGAS;\n    address public CONFIG;\n    address public FACTORY;\n    address public WETH;\n    address public GOVERNANCE;\n    address public TRANSFER_LISTENER;\n    address public POOL;\n    uint256 public constant PERCENT_DENOMINATOR = 10000;\n\n    bool public isPause;\n\n    event AddLiquidity(\n        address indexed player,\n        address indexed tokenA,\n        address indexed tokenB,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event RemoveLiquidity(\n        address indexed player,\n        address indexed tokenA,\n        address indexed tokenB,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event SwapToken(\n        address indexed receiver,\n        address indexed fromToken,\n        address indexed toToken,\n        uint256 inAmount,\n        uint256 outAmount\n    );\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n    }\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, 'TOMI PLATFORM : EXPIRED');\n        _;\n    }\n\n    modifier noneTokenCall() {\n        require(ITokenRegistry(CONFIG).tokenStatus(msg.sender) == 0, 'TOMI PLATFORM : ILLEGAL CALL');\n        _;\n    }\n\n    function initialize(\n        address _TGAS,\n        address _CONFIG,\n        address _FACTORY,\n        address _WETH,\n        address _GOVERNANCE,\n        address _TRANSFER_LISTENER,\n        address _POOL\n    ) external onlyOwner {\n        TGAS = _TGAS;\n        CONFIG = _CONFIG;\n        FACTORY = _FACTORY;\n        WETH = _WETH;\n        GOVERNANCE = _GOVERNANCE;\n        TRANSFER_LISTENER = _TRANSFER_LISTENER;\n        POOL = _POOL;\n    }\n\n    function pause() external onlyOwner {\n        isPause = true;\n    }\n\n    function resume() external onlyOwner {\n        isPause = false;\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        if (ITomiFactory(FACTORY).getPair(tokenA, tokenB) == address(0)) {\n            ITomiConfig(CONFIG).addToken(tokenA);\n            ITomiConfig(CONFIG).addToken(tokenB);\n            ITomiFactory(FACTORY).createPair(tokenA, tokenB);\n        }\n        require(\n            ITomiConfig(CONFIG).checkPair(tokenA, tokenB),\n            'TOMI PLATFORM : ADD LIQUIDITY PAIR CONFIG CHECK FAIL'\n        );\n        (uint256 reserveA, uint256 reserveB) = TomiSwapLibrary.getReserves(FACTORY, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = TomiSwapLibrary.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'TOMI PLATFORM : INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = TomiSwapLibrary.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'TOMI PLATFORM : INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n        ITomiFactory(FACTORY).addPlayerPair(msg.sender, ITomiFactory(FACTORY).getPair(tokenA, tokenB));\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 deadline\n    )\n        external\n        ensure(deadline)\n        returns (\n            uint256 _amountA,\n            uint256 _amountB,\n            uint256 _liquidity\n        )\n{\n        require(!isPause, \"TOMI PAUSED\");\n        (_amountA, _amountB) = _addLiquidity(tokenA, tokenB, amountA, amountB, amountAMin, amountBMin);\n        address pair = TomiSwapLibrary.pairFor(FACTORY, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, _amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, _amountB);\n\n        // notify pool\n        ITomiPool(POOL).preProductivityChanged(pair, msg.sender);\n        _liquidity = ITomiPair(pair).mint(msg.sender);\n        ITomiPool(POOL).postProductivityChanged(pair, msg.sender);\n\n        _transferNotify(msg.sender, pair, tokenA, _amountA);\n        _transferNotify(msg.sender, pair, tokenB, _amountB);\n        emit AddLiquidity(msg.sender, tokenA, tokenB, _amountA, _amountB);\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        uint256 deadline\n    )\n        external\n        payable\n        ensure(deadline)\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        require(!isPause, \"TOMI PAUSED\");\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = TomiSwapLibrary.pairFor(FACTORY, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n\n        // notify pool\n        ITomiPool(POOL).preProductivityChanged(pair, msg.sender);\n        liquidity = ITomiPair(pair).mint(msg.sender);\n        ITomiPool(POOL).postProductivityChanged(pair, msg.sender);\n\n        _transferNotify(msg.sender, pair, WETH, amountETH);\n        _transferNotify(msg.sender, pair, token, amountToken);\n        emit AddLiquidity(msg.sender, token, WETH, amountToken, amountETH);\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) public ensure(deadline) returns (uint256 amountA, uint256 amountB) {\n        require(!isPause, \"TOMI PAUSED\");\n        address pair = TomiSwapLibrary.pairFor(FACTORY, tokenA, tokenB);\n        uint256 _liquidity = liquidity;\n        address _tokenA = tokenA;\n        address _tokenB = tokenB;\n\n        // notify pool\n        ITomiPool(POOL).preProductivityChanged(pair, msg.sender);\n        (uint256 amount0, uint256 amount1) = ITomiPair(pair).burn(msg.sender, to, _liquidity);\n        ITomiPool(POOL).postProductivityChanged(pair, msg.sender);\n\n        (address token0, ) = TomiSwapLibrary.sortTokens(_tokenA, _tokenB);\n        (amountA, amountB) = _tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        _transferNotify(pair, to, _tokenA, amountA);\n        _transferNotify(pair, to, _tokenB, amountB);\n        require(amountA >= amountAMin, 'TOMI PLATFORM : INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'TOMI PLATFORM : INSUFFICIENT_B_AMOUNT');\n        emit RemoveLiquidity(msg.sender, _tokenA, _tokenB, amountA, amountB);\n    }\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) public ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {\n        require(!isPause, \"TOMI PAUSED\");\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n        _transferNotify(address(this), to, token, amountToken);\n        _transferNotify(address(this), to, WETH, amountETH);\n    }\n\n    function _getAmountsOut(\n        uint256 amount,\n        address[] memory path,\n        uint256 percent\n    ) internal view returns (uint256[] memory amountOuts) {\n        amountOuts = new uint256[](path.length);\n        amountOuts[0] = amount;\n        for (uint256 i = 0; i < path.length - 1; i++) {\n            address inPath = path[i];\n            address outPath = path[i + 1];\n            (uint256 reserveA, uint256 reserveB) = TomiSwapLibrary.getReserves(FACTORY, inPath, outPath);\n            uint256 outAmount = SafeMath.mul(amountOuts[i], SafeMath.sub(PERCENT_DENOMINATOR, percent));\n            amountOuts[i + 1] = TomiSwapLibrary.getAmountOut(outAmount / PERCENT_DENOMINATOR, reserveA, reserveB);\n        }\n    }\n\n    function _getAmountsIn(\n        uint256 amount,\n        address[] memory path,\n        uint256 percent\n    ) internal view returns (uint256[] memory amountIn) {\n        amountIn = new uint256[](path.length);\n        amountIn[path.length - 1] = amount;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            address inPath = path[i - 1];\n            address outPath = path[i];\n            (uint256 reserveA, uint256 reserveB) = TomiSwapLibrary.getReserves(FACTORY, inPath, outPath);\n            uint256 inAmount = TomiSwapLibrary.getAmountIn(amountIn[i], reserveA, reserveB);\n            amountIn[i - 1] = SafeMath.add(\n                SafeMath.mul(inAmount, PERCENT_DENOMINATOR) / SafeMath.sub(PERCENT_DENOMINATOR, percent),\n                1\n            );\n        }\n        amountIn = _getAmountsOut(amountIn[0], path, percent);\n    }\n\n    function swapPrecondition(address token) public view returns (bool) {\n        if (token == TGAS || token == WETH) return true;\n        uint256 percent = ITomiConfig(CONFIG).getConfigValue(ConfigNames.TOKEN_TO_TGAS_PAIR_MIN_PERCENT);\n        if (!existPair(WETH, TGAS)) return false;\n        if (!existPair(TGAS, token)) return false;\n        if (!(ITomiConfig(CONFIG).checkPair(TGAS, token) && ITomiConfig(CONFIG).checkPair(WETH, token))) return false;\n        if (!existPair(WETH, token)) return true;\n        if (percent == 0) return true;\n        (uint256 reserveTGAS, ) = TomiSwapLibrary.getReserves(FACTORY, TGAS, token);\n        (uint256 reserveWETH, ) = TomiSwapLibrary.getReserves(FACTORY, WETH, token);\n        (uint256 reserveWETH2, uint256 reserveTGAS2) = TomiSwapLibrary.getReserves(FACTORY, WETH, TGAS);\n        uint256 tgasValue = SafeMath.mul(reserveTGAS, reserveWETH2) / reserveTGAS2;\n        uint256 limitValue = SafeMath.mul(SafeMath.add(tgasValue, reserveWETH), percent) / PERCENT_DENOMINATOR;\n        return tgasValue >= limitValue;\n    }\n         \n    function checkPath(address _path, address[] memory _paths) public pure returns (bool) {\n        uint count;\n        for(uint i; i<_paths.length; i++) {\n            if(_paths[i] == _path) {\n                count++;\n            }\n        }\n        if(count == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _swap(\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal {\n        require(!isPause, \"TOMI PAUSED\");\n        require(swapPrecondition(path[path.length - 1]), 'TOMI PLATFORM : CHECK TGAS/TOKEN TO VALUE FAIL');\n        for (uint256 i; i < path.length - 1; i++) {\n            require(checkPath(path[i], path) && checkPath(path[i + 1], path), 'DEMAX PLATFORM : INVALID PATH');\n            (address input, address output) = (path[i], path[i + 1]);\n            require(swapPrecondition(input), 'TOMI PLATFORM : CHECK TGAS/TOKEN VALUE FROM FAIL');\n            require(ITomiConfig(CONFIG).checkPair(input, output), 'TOMI PLATFORM : SWAP PAIR CONFIG CHECK FAIL');\n            (address token0, address token1) = TomiSwapLibrary.sortTokens(input, output);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n            address to = i < path.length - 2 ? TomiSwapLibrary.pairFor(FACTORY, output, path[i + 2]) : _to;\n\n            // add k check\n            address pair = TomiSwapLibrary.pairFor(FACTORY, input, output);\n            (uint reserve0, uint resereve1, ) = ITomiPair(pair).getReserves();\n            uint kBefore = SafeMath.mul(reserve0, resereve1);\n\n            ITomiPair(pair).swap(amount0Out, amount1Out, to, new bytes(0));\n\n            (reserve0, resereve1, ) = ITomiPair(pair).getReserves();\n            uint kAfter = SafeMath.mul(reserve0, resereve1);\n            require(kBefore <= kAfter, \"Burger K\");\n\n            if (amount0Out > 0)\n                _transferNotify(TomiSwapLibrary.pairFor(FACTORY, input, output), to, token0, amount0Out);\n            if (amount1Out > 0)\n                _transferNotify(TomiSwapLibrary.pairFor(FACTORY, input, output), to, token1, amount1Out);\n        }\n        emit SwapToken(_to, path[0], path[path.length - 1], amounts[0], amounts[path.length - 1]);\n    }\n\n    function _swapFee(\n        uint256[] memory amounts,\n        address[] memory path,\n        uint256 percent\n    ) internal {\n        console.log(\"zxc\");\n        for (uint256 i = 0; i < path.length - 1; i++) {\n            uint256 fee = SafeMath.mul(amounts[i], percent) / PERCENT_DENOMINATOR;\n            address input = path[i];\n            address output = path[i + 1];\n            address currentPair = TomiSwapLibrary.pairFor(FACTORY, input, output);\n            if (input == TGAS) {\n                ITomiPair(currentPair).swapFee(fee, TGAS, POOL);\n                _transferNotify(currentPair, POOL, TGAS, fee);\n            } else {\n                ITomiPair(currentPair).swapFee(fee, input, TomiSwapLibrary.pairFor(FACTORY, input, TGAS));\n                (uint256 reserveIn, uint256 reserveTGAS) = TomiSwapLibrary.getReserves(FACTORY, input, TGAS);\n                uint256 feeOut = TomiSwapLibrary.getAmountOut(fee, reserveIn, reserveTGAS);\n                ITomiPair(TomiSwapLibrary.pairFor(FACTORY, input, TGAS)).swapFee(feeOut, TGAS, POOL);\n                _transferNotify(currentPair, TomiSwapLibrary.pairFor(FACTORY, input, TGAS), input, fee);\n                _transferNotify(TomiSwapLibrary.pairFor(FACTORY, input, TGAS), POOL, TGAS, feeOut);\n                fee = feeOut;\n            }\n            if (fee > 0) ITomiPool(POOL).addRewardFromPlatform(currentPair, fee);\n        }\n    }\n\n    function _getSwapFeePercent() internal view returns (uint256) {\n        return ITomiConfig(CONFIG).getConfigValue(ConfigNames.SWAP_FEE_PERCENT);\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n\n        uint256 percent = _getSwapFeePercent();\n        amounts = _getAmountsOut(amountIn, path, percent);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'TOMI PLATFORM : INSUFFICIENT_OUTPUT_AMOUNT');\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\n        _innerTransferFrom(\n            path[0],\n            msg.sender,\n            pair,\n            SafeMath.mul(amountIn, SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\n        );\n        _swap(amounts, path, to);\n        _innerTransferFrom(path[0], msg.sender, pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\n        _swapFee(amounts, path, percent);\n    }\n\n    function _innerTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        TransferHelper.safeTransferFrom(token, from, to, amount);\n        _transferNotify(from, to, token, amount);\n    }\n\n    function _innerTransferWETH(address to, uint256 amount) internal {\n        assert(IWETH(WETH).transfer(to, amount));\n        _transferNotify(address(this), to, WETH, amount);\n    }\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable ensure(deadline) returns (uint256[] memory amounts) {\n        require(path[0] == WETH, 'TOMI PLATFORM : INVALID_PATH');\n        uint256 percent = _getSwapFeePercent();\n        amounts = _getAmountsOut(msg.value, path, percent);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'TOMI PLATFORM : INSUFFICIENT_OUTPUT_AMOUNT');\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\n        IWETH(WETH).deposit{\n            value: SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\n        }();\n        _innerTransferWETH(\n            pair,\n            SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\n        );\n        _swap(amounts, path, to);\n\n        IWETH(WETH).deposit{value: SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR}();\n        _innerTransferWETH(pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\n        _swapFee(amounts, path, percent);\n    }\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        require(path[path.length - 1] == WETH, 'TOMI PLATFORM : INVALID_PATH');\n        uint256 percent = _getSwapFeePercent();\n        amounts = _getAmountsOut(amountIn, path, percent);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'TOMI PLATFORM : INSUFFICIENT_OUTPUT_AMOUNT');\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\n        _innerTransferFrom(\n            path[0],\n            msg.sender,\n            pair,\n            SafeMath.mul(amountIn, SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\n        );\n        _swap(amounts, path, address(this));\n\n        _innerTransferFrom(path[0], msg.sender, pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\n        _swapFee(amounts, path, percent);\n\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        uint256 percent = _getSwapFeePercent();\n        amounts = _getAmountsIn(amountOut, path, percent);\n        require(amounts[0] <= amountInMax, 'TOMI PLATFORM : EXCESSIVE_INPUT_AMOUNT');\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\n\n        _innerTransferFrom(\n            path[0],\n            msg.sender,\n            pair,\n            SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\n        );\n        _swap(amounts, path, to);\n        _innerTransferFrom(path[0], msg.sender, pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\n        _swapFee(amounts, path, percent);\n    }\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\n        require(path[path.length - 1] == WETH, 'TOMI PLATFORM : INVALID_PATH');\n        uint256 percent = _getSwapFeePercent();\n        amounts = _getAmountsIn(amountOut, path, percent);\n        require(amounts[0] <= amountInMax, 'TOMI PLATFORM : EXCESSIVE_INPUT_AMOUNT');\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\n        _innerTransferFrom(\n            path[0],\n            msg.sender,\n            pair,\n            SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n\n        _innerTransferFrom(path[0], msg.sender, pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\n        _swapFee(amounts, path, percent);\n    }\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable ensure(deadline) returns (uint256[] memory amounts) {\n        require(path[0] == WETH, 'TOMI PLATFORM : INVALID_PATH');\n        uint256 percent = _getSwapFeePercent();\n        amounts = _getAmountsIn(amountOut, path, percent);\n        require(amounts[0] <= msg.value, 'TOMI PLATFORM : EXCESSIVE_INPUT_AMOUNT');\n\n        IWETH(WETH).deposit{\n            value: SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\n        }();\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\n        _innerTransferWETH(\n            pair,\n            SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\n        );\n        _swap(amounts, path, to);\n\n        IWETH(WETH).deposit{value: SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR}();\n        _innerTransferWETH(pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\n        _swapFee(amounts, path, percent);\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    function _transferNotify(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) internal {\n        ITomiTransferListener(TRANSFER_LISTENER).transferNotify(from, to, token, amount);\n    }\n\n    function existPair(address tokenA, address tokenB) public view returns (bool) {\n        return ITomiFactory(FACTORY).getPair(tokenA, tokenB) != address(0);\n    }\n\n    function getReserves(address tokenA, address tokenB) public view returns (uint256, uint256) {\n        return TomiSwapLibrary.getReserves(FACTORY, tokenA, tokenB);\n    }\n\n    function pairFor(address tokenA, address tokenB) public view returns (address) {\n        return TomiSwapLibrary.pairFor(FACTORY, tokenA, tokenB);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public view returns (uint256 amountOut) {\n        uint256 percent = _getSwapFeePercent();\n        uint256 amount = SafeMath.mul(amountIn, SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR;\n        return TomiSwapLibrary.getAmountOut(amount, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public view returns (uint256 amountIn) {\n        uint256 percent = _getSwapFeePercent();\n        uint256 amount = TomiSwapLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\n        return SafeMath.mul(amount, PERCENT_DENOMINATOR) / SafeMath.sub(PERCENT_DENOMINATOR, percent);\n    }\n\n    function getAmountsOut(uint256 amountIn, address[] memory path) public view returns (uint256[] memory amounts) {\n        uint256 percent = _getSwapFeePercent();\n        return _getAmountsOut(amountIn, path, percent);\n    }\n\n    function getAmountsIn(uint256 amountOut, address[] memory path) public view returns (uint256[] memory amounts) {\n        uint256 percent = _getSwapFeePercent();\n        return _getAmountsIn(amountOut, path, percent);\n    }\n\n    function migrateLiquidity(address pair, address tokenA, address tokenB, address[] calldata users) external onlyOwner {\n        if (ITomiFactory(FACTORY).getPair(tokenA, tokenB) == address(0)) {\n            ITomiFactory(FACTORY).createPair(tokenA, tokenB);\n        }\n        address newPair = ITomiFactory(FACTORY).getPair(tokenA, tokenB);\n        for(uint i = 0; i < users.length; i++) {\n            uint liquidity = ITomiPair(pair).balanceOf(users[i]);\n            if(liquidity > 0) {\n                ITomiPair(pair).burn(users[i], newPair, liquidity);\n                ITomiPair(newPair).mint(users[i]);\n                ITomiFactory(FACTORY).addPlayerPair(users[i], newPair);\n            }\n        }\n\n        ITomiTransferListener(TRANSFER_LISTENER).upgradeProdutivity(pair, newPair);    \n\n    }\n}"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n"
    },
    "contracts/interfaces/ITomiPool.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface ITomiPool {\n    function addRewardFromPlatform(address _pair, uint _amount) external;\n    function preProductivityChanged(address _pair, address _user) external;\n    function postProductivityChanged(address _pair, address _user) external;\n}"
    },
    "contracts/modules/ReentrancyGuard.sol": {
      "content": "/**\n *Submitted for verification at BscScan.com on 2021-06-30\n*/\n\npragma solidity >=0.6.6;\n\ninterface IDemaxTransferListener {\n    function transferNotify(address from, address to, address token, uint amount)  external returns (bool);\n    function upgradeProdutivity(address fromPair, address toPair) external;\n}\n// Dependency file: contracts/modules/ReentrancyGuard.sol\n\n// SPDX-License-Identifier: MIT\n\n// pragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/ITomiTransferListener.sol": {
      "content": "pragma solidity >=0.6.6;\n\ninterface ITomiTransferListener {\n    function transferNotify(address from, address to, address token, uint amount)  external returns (bool);\n    function upgradeProdutivity(address fromPair, address toPair) external;\n}"
    },
    "contracts/interfaces/ITokenRegistry.sol": {
      "content": "pragma solidity >=0.5.16;\n\ninterface ITokenRegistry {\n    function tokenStatus(address _token) external view returns(uint);\n    function pairStatus(address tokenA, address tokenB) external view returns (uint);\n    function NONE() external view returns(uint);\n    function REGISTERED() external view returns(uint);\n    function PENDING() external view returns(uint);\n    function OPENED() external view returns(uint);\n    function CLOSED() external view returns(uint);\n    function registryToken(address _token) external returns (bool);\n    function publishToken(address _token) external returns (bool);\n    function updateToken(address _token, uint _status) external returns (bool);\n    function updatePair(address tokenA, address tokenB, uint _status) external returns (bool);\n    function tokenCount() external view returns(uint);\n    function validTokens() external view returns(address[] memory);\n    function iterateValidTokens(uint32 _start, uint32 _end) external view returns (address[] memory);\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/TomiGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport './interfaces/ITomiConfig.sol';\nimport './interfaces/ITomiBallotFactory.sol';\nimport './interfaces/ITomiBallot.sol';\nimport './interfaces/ITgas.sol';\nimport './interfaces/ITokenRegistry.sol';\nimport './libraries/ConfigNames.sol';\nimport './libraries/TransferHelper.sol';\nimport './modules/TgasStaking.sol';\nimport './modules/Ownable.sol';\n\ncontract TomiGovernance is TgasStaking, Ownable {\n    uint public version = 1;\n    address public configAddr;\n    address public ballotFactoryAddr;\n    address public rewardAddr;\n\n    uint public T_CONFIG = 1;\n    uint public T_LIST_TOKEN = 2;\n    uint public T_TOKEN = 3;\n    mapping(address => uint) public ballotTypes;\n    mapping(address => bytes32) public configBallots;\n    mapping(address => address) public tokenBallots;\n    mapping(address => uint) public rewardOf;\n    mapping(address => uint) public ballotOf;\n    mapping(address => mapping(address => uint)) public applyTokenOf;\n    mapping(address => mapping(address => bool)) public collectUsers;\n    mapping(address => address) public tokenUsers;\n\n    address[] public ballots;\n\n    event ConfigAudited(bytes32 name, address indexed ballot, uint proposal);\n    event ConfigBallotCreated(address indexed proposer, bytes32 name, uint value, address indexed ballotAddr, uint reward);\n    event TokenBallotCreated(address indexed proposer, address indexed token, uint value, address indexed ballotAddr, uint reward);\n    event ProposalerRewardRateUpdated(uint oldVaue, uint newValue);\n    event RewardTransfered(address indexed from, address indexed to, uint value);\n    event TokenListed(address user, address token, uint amount);\n    event ListTokenAudited(address user, address token, uint status, uint burn, uint reward, uint refund);\n    event TokenAudited(address user, address token, uint status, bool result);\n    event RewardCollected(address indexed user, address indexed ballot, uint value);\n    event RewardReceived(address indexed user, uint value);\n\n    modifier onlyRewarder() {\n        require(msg.sender == rewardAddr, 'TomiGovernance: ONLY_REWARDER');\n        _;\n    }\n\n    constructor (address _tgas) TgasStaking(_tgas) public {\n    }\n\n    // called after deployment\n    function initialize(address _rewardAddr, address _configContractAddr, address _ballotFactoryAddr) external onlyOwner {\n        require(_rewardAddr != address(0) && _configContractAddr != address(0) && _ballotFactoryAddr != address(0), 'TomiGovernance: INPUT_ADDRESS_IS_ZERO');\n\n        rewardAddr = _rewardAddr;\n        configAddr = _configContractAddr;\n        ballotFactoryAddr = _ballotFactoryAddr;\n        lockTime = getConfigValue(ConfigNames.UNSTAKE_DURATION);\n    }\n\n    function audit(address _ballot) external returns (bool) {\n        if(ballotTypes[_ballot] == T_CONFIG) {\n            return auditConfig(_ballot);\n        } else if (ballotTypes[_ballot] == T_LIST_TOKEN) {\n            return auditListToken(_ballot);\n        } else if (ballotTypes[_ballot] == T_TOKEN) {\n            return auditToken(_ballot);\n        } else {\n            revert('TomiGovernance: UNKNOWN_TYPE');\n        }\n    }\n\n    function auditConfig(address _ballot) public returns (bool) {\n        bool result = ITomiBallot(_ballot).end();\n        require(result, 'TomiGovernance: NO_PASS');\n        uint value = ITomiBallot(_ballot).value();\n        bytes32 name = configBallots[_ballot];\n        result = ITomiConfig(configAddr).changeConfigValue(name, value);\n        if (name == ConfigNames.UNSTAKE_DURATION) {\n            lockTime = value;\n        } else if (name == ConfigNames.PRODUCE_TGAS_RATE) {\n            _changeAmountPerBlock(value);\n        }\n        emit ConfigAudited(name, _ballot, value);\n        return result;\n    }\n\n    function auditListToken(address _ballot) public returns (bool) {\n        bool result = ITomiBallot(_ballot).end();\n        address token = tokenBallots[_ballot];\n        address user = tokenUsers[token];\n        require(ITokenRegistry(configAddr).tokenStatus(token) == ITokenRegistry(configAddr).REGISTERED(), 'TomiGovernance: AUDITED');\n        uint status = result ? ITokenRegistry(configAddr).PENDING() : ITokenRegistry(configAddr).CLOSED();\n\t    uint amount = applyTokenOf[user][token];\n        (uint burnAmount, uint rewardAmount, uint refundAmount) = (0, 0, 0);\n        if (result) {\n            burnAmount = amount * getConfigValue(ConfigNames.LIST_TOKEN_SUCCESS_BURN_PRECENT) / ITomiConfig(configAddr).PERCENT_DENOMINATOR();\n            rewardAmount = amount - burnAmount;\n            if (burnAmount > 0) {\n                TransferHelper.safeTransfer(baseToken, address(0), burnAmount);\n                totalSupply = totalSupply.sub(burnAmount);\n            }\n            if (rewardAmount > 0) {\n                rewardOf[rewardAddr] = rewardOf[rewardAddr].add(rewardAmount);\n                ballotOf[_ballot] = ballotOf[_ballot].add(rewardAmount);\n                _rewardTransfer(rewardAddr, _ballot, rewardAmount);\n            }\n            ITokenRegistry(configAddr).publishToken(token);\n        } else {\n            burnAmount = amount * getConfigValue(ConfigNames.LIST_TOKEN_FAILURE_BURN_PRECENT) / ITomiConfig(configAddr).PERCENT_DENOMINATOR();\n            refundAmount = amount - burnAmount;\n            if (burnAmount > 0) TransferHelper.safeTransfer(baseToken, address(0), burnAmount);\n            if (refundAmount > 0) TransferHelper.safeTransfer(baseToken, user, refundAmount);\n            totalSupply = totalSupply.sub(amount);\n            ITokenRegistry(configAddr).updateToken(token, status);\n        }\n\t    emit ListTokenAudited(user, token, status, burnAmount, rewardAmount, refundAmount);\n        return result;\n    }\n\n    function auditToken(address _ballot) public returns (bool) {\n        bool result = ITomiBallot(_ballot).end();\n        uint status = ITomiBallot(_ballot).value();\n        address token = tokenBallots[_ballot];\n        address user = tokenUsers[token];\n        require(ITokenRegistry(configAddr).tokenStatus(token) != status, 'TomiGovernance: TOKEN_STATUS_NO_CHANGE');\n        if (result) {\n            ITokenRegistry(configAddr).updateToken(token, status);\n        } else {\n            status = ITokenRegistry(configAddr).tokenStatus(token);\n        }\n\t    emit TokenAudited(user, token, status, result);\n        return result;\n    }\n\n    function getConfigValue(bytes32 _name) public view returns (uint) {\n        return ITomiConfig(configAddr).getConfigValue(_name);\n    }\n\n    function createConfigBallot(bytes32 _name, uint _value, uint _amount, bool _wallet, string calldata _subject, string calldata _content) external returns (address) {\n        require(_value >= 0, 'TomiGovernance: INVALID_PARAMTERS');\n        { // avoids stack too deep errors\n        (uint minValue, uint maxValue, uint maxSpan, uint value, uint enable) = ITomiConfig(configAddr).getConfig(_name);\n        require(enable == 1, \"TomiGovernance: CONFIG_DISABLE\");\n        require(_value >= minValue && _value <= maxValue, \"TomiGovernance: OUTSIDE\");\n        uint span = _value >= value? (_value - value) : (value - _value);\n        require(maxSpan >= span, \"TomiGovernance: OVERSTEP\");\n        }\n        require(_amount >= getConfigValue(ConfigNames.PROPOSAL_TGAS_AMOUNT), \"TomiGovernance: NOT_ENOUGH_AMOUNT_TO_PROPOSAL\");\n        if(_amount > 0) {\n            _amount = _transferForBallot(_amount, _wallet);\n            rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_amount);\n        }\n        uint endBlockNumber = block.number + getConfigValue(ConfigNames.VOTE_DURATION);\n        address ballotAddr = ITomiBallotFactory(ballotFactoryAddr).create(msg.sender, _value, endBlockNumber, _subject, _content);\n        configBallots[ballotAddr] = _name;\n        uint reward = _createdBallot(ballotAddr, T_CONFIG);\n        emit ConfigBallotCreated(msg.sender, _name, _value, ballotAddr, reward);\n        return ballotAddr;\n    }\n\n    function createTokenBallot(address _token, uint _value, uint _amount, bool _wallet, string calldata _subject, string calldata _content) external returns (address) {\n        require(!_isDefaultToken(_token), 'TomiGovernance: DEFAULT_LIST_TOKENS_PROPOSAL_DENY');\n        uint status = ITokenRegistry(configAddr).tokenStatus(_token);\n        require(status == ITokenRegistry(configAddr).PENDING(), 'TomiGovernance: ONLY_ALLOW_PENDING');\n        require(_value == ITokenRegistry(configAddr).OPENED() || _value == ITokenRegistry(configAddr).CLOSED(), 'TomiGovernance: INVALID_STATUS');\n        require(status != _value, 'TomiGovernance: STATUS_NO_CHANGE');\n        require(_amount >= getConfigValue(ConfigNames.PROPOSAL_TGAS_AMOUNT), \"TomiGovernance: NOT_ENOUGH_AMOUNT_TO_PROPOSAL\");\n        if(_amount > 0) {\n            _amount = _transferForBallot(_amount, _wallet);\n            rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_amount);\n        }\n        address ballotAddr = _createTokenBallot(T_TOKEN, _token, _value, _subject, _content);\n        return ballotAddr;\n    }\n\n\tfunction listToken(address _token, uint _amount, bool _wallet, string calldata _subject, string calldata _content) external returns (address) {\n        uint status = ITokenRegistry(configAddr).tokenStatus(_token);\n        require(status == ITokenRegistry(configAddr).NONE() || status == ITokenRegistry(configAddr).CLOSED(), 'TomiGovernance: LISTED');\n\t    require(_amount >= getConfigValue(ConfigNames.LIST_TGAS_AMOUNT), \"TomiGovernance: NOT_ENOUGH_AMOUNT_TO_LIST\");\n\t    tokenUsers[_token] = msg.sender;\n        if(_amount > 0) {\n            applyTokenOf[msg.sender][_token] = _transferForBallot(_amount, _wallet);\n        }\n\t    ITokenRegistry(configAddr).registryToken(_token);\n        address ballotAddr = _createTokenBallot(T_LIST_TOKEN, _token, ITokenRegistry(configAddr).PENDING(), _subject, _content);\n\t    emit TokenListed(msg.sender, _token, _amount);\n        return ballotAddr;\n\t}\n\n    function _createTokenBallot(uint _type, address _token, uint _value, string memory _subject, string memory _content) private returns (address) {\n        uint endBlockNumber = block.number + getConfigValue(ConfigNames.VOTE_DURATION);\n        address ballotAddr = ITomiBallotFactory(ballotFactoryAddr).create(msg.sender, _value, endBlockNumber, _subject, _content);\n        uint reward = _createdBallot(ballotAddr, _type);\n        ballotOf[ballotAddr] = reward;\n        tokenBallots[ballotAddr] = _token;\n        emit TokenBallotCreated(msg.sender, _token, _value, ballotAddr, reward);\n        return ballotAddr;\n    }\n\n    function collectReward(address _ballot) external returns (uint) {\n        require(block.number >= ITomiBallot(_ballot).endBlockNumber(), \"TomiGovernance: NOT_YET_ENDED\");\n        require(!collectUsers[_ballot][msg.sender], 'TomiGovernance: REWARD_COLLECTED');\n        uint amount = getReward(_ballot);\n        _rewardTransfer(_ballot, msg.sender, amount);\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\n        stakingSupply = stakingSupply.add(amount);\n        rewardOf[msg.sender] = rewardOf[msg.sender].sub(amount);\n        collectUsers[_ballot][msg.sender] = true;\n        emit RewardCollected(msg.sender, _ballot, amount);\n    }\n\n    function getReward(address _ballot) public view returns (uint) {\n        if (block.number < ITomiBallot(_ballot).endBlockNumber() || collectUsers[_ballot][msg.sender]) {\n            return 0;\n        }\n        uint amount;\n        uint shares = ballotOf[_ballot];\n        if (ITomiBallot(_ballot).result()) {\n            uint extra;\n            uint rewardRate = getConfigValue(ConfigNames.VOTE_REWARD_PERCENT);\n            if ( rewardRate > 0) {\n               extra = shares * rewardRate / ITomiConfig(configAddr).PERCENT_DENOMINATOR();\n               shares -= extra;\n            }\n            if (msg.sender == ITomiBallot(_ballot).proposer()) {\n                amount = extra;\n            }\n        }\n\n        if (ITomiBallot(_ballot).total() > 0) {\n            amount += shares * ITomiBallot(_ballot).weight(msg.sender) / ITomiBallot(_ballot).total();\n        }\n        return amount;\n    }\n\n    // TOMI TEST ONLY\n    // function addReward(uint _value) external onlyRewarder returns (bool) {\n    function addReward(uint _value) external returns (bool) {\n        require(_value > 0, 'TomiGovernance: ADD_REWARD_VALUE_IS_ZERO');\n        uint total = IERC20(baseToken).balanceOf(address(this));\n        uint diff = total.sub(totalSupply);\n        require(_value <= diff, 'TomiGovernance: ADD_REWARD_EXCEED');\n        rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_value);\n        totalSupply = total;\n        emit RewardReceived(rewardAddr, _value);\n    }\n\n    function _rewardTransfer(address _from, address _to, uint _value) private returns (bool) {\n        require(_value >= 0 && rewardOf[_from] >= _value, 'TomiGovernance: INSUFFICIENT_BALANCE');\n        rewardOf[_from] = rewardOf[_from].sub(_value);\n        rewardOf[_to] = rewardOf[_to].add(_value);\n        emit RewardTransfered(_from, _to, _value);\n    }\n\n    function _isDefaultToken(address _token) internal returns (bool) {\n        address[] memory tokens = ITomiConfig(configAddr).getDefaultListTokens();\n        for(uint i = 0 ; i < tokens.length; i++){\n            if (tokens[i] == _token) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _transferForBallot(uint _amount, bool _wallet) internal returns (uint) {\n        if (_wallet) {\n            TransferHelper.safeTransferFrom(baseToken, msg.sender, address(this), _amount);\n            totalSupply += _amount;\n        } else {\n            _reduce(msg.sender, _amount);\n        }\n        return _amount;\n    }\n\n    function _createdBallot(address _ballot, uint _type) internal returns (uint) {\n        uint reward = rewardOf[rewardAddr];\n        ballotOf[_ballot] = reward;\n        _rewardTransfer(rewardAddr, _ballot, reward);\n        ballots.push(_ballot);\n        ballotTypes[_ballot] = _type;\n        return reward;\n    }\n\n    function ballotCount() external view returns (uint) {\n        return ballots.length;\n    }\n\n    function _changeAmountPerBlock(uint _value) internal returns (bool) {\n        return ITgas(baseToken).changeInterestRatePerBlock(_value);\n    }\n\n    function updateTgasGovernor(address _new) external onlyOwner {\n        ITgas(baseToken).upgradeGovernance(_new);\n    }\n\n    function upgradeApproveReward() external returns (uint) {\n        require(rewardOf[rewardAddr] > 0, 'TomiGovernance: UPGRADE_NO_REWARD');\n        require(ITomiConfig(configAddr).governor() != address(this), 'TomiGovernance: UPGRADE_NO_CHANGE');\n        TransferHelper.safeApprove(baseToken, ITomiConfig(configAddr).governor(), rewardOf[rewardAddr]);\n        return rewardOf[rewardAddr]; \n    }\n\n    function receiveReward(address _from, uint _value) external returns (bool) {\n        require(_value > 0, 'TomiGovernance: RECEIVE_REWARD_VALUE_IS_ZERO');\n        TransferHelper.safeTransferFrom(baseToken, _from, address(this), _value);\n        rewardOf[rewardAddr] += _value;\n        totalSupply += _value;\n        emit RewardReceived(_from, _value);\n        return true;\n    }\n\n}"
    },
    "contracts/interfaces/ITomiBallotFactory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface ITomiBallotFactory {\n    function create(\n        address _proposer,\n        uint _value,\n        uint _endBlockNumber,\n        string calldata _subject,\n        string calldata _content\n    ) external returns (address);\n}"
    },
    "contracts/interfaces/ITomiBallot.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface ITomiBallot {\n    function proposer() external view returns(address);\n    function endBlockNumber() external view returns(uint);\n    function value() external view returns(uint);\n    function result() external view returns(bool);\n    function end() external returns (bool);\n    function total() external view returns(uint);\n    function weight(address user) external view returns (uint);\n}"
    },
    "contracts/modules/TgasStaking.sol": {
      "content": "pragma solidity >=0.5.16;\n\nimport '../libraries/TransferHelper.sol';\nimport '../libraries/SafeMath.sol';\nimport '../interfaces/IERC20.sol';\nimport '../interfaces/ITomiConfig.sol';\nimport '../modules/BaseToken.sol';\n\n\ncontract TgasStaking is BaseToken {\n    using SafeMath for uint;\n\n    uint public lockTime;\n    uint public totalSupply;\n    uint public stakingSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => uint) public allowance;\n\n\n    constructor (address _baseToken) public {\n        initBaseToken(_baseToken);\n    }\n\n    function _add(address user, uint value) internal {\n        require(value > 0, 'ZERO');\n        balanceOf[user] = balanceOf[user].add(value);\n        stakingSupply = stakingSupply.add(value);\n        allowance[user] = block.number;\n    }\n\n    function _reduce(address user, uint value) internal {\n        require(balanceOf[user] >= value && value > 0, 'TgasStaking: INSUFFICIENT_BALANCE');\n        balanceOf[user] = balanceOf[user].sub(value);\n        stakingSupply = stakingSupply.sub(value);\n    }\n\n    function deposit(uint _amount) external returns (bool) {\n        TransferHelper.safeTransferFrom(baseToken, msg.sender, address(this), _amount);\n        _add(msg.sender, _amount);\n        totalSupply = IERC20(baseToken).balanceOf(address(this));\n        return true;\n    }\n\n    function withdraw(uint _amount) external returns (bool) {\n        require(block.number > allowance[msg.sender] + lockTime, 'TgasStaking: NOT_DUE');\n        TransferHelper.safeTransfer(baseToken, msg.sender, _amount);\n        _reduce(msg.sender, _amount);\n        totalSupply = IERC20(baseToken).balanceOf(address(this));\n        return true;\n    }\n\n}"
    },
    "contracts/modules/BaseToken.sol": {
      "content": "\npragma solidity >=0.5.16;\n\ncontract BaseToken {\n    address public baseToken;\n\n    // called after deployment\n    function initBaseToken(address _baseToken) internal {\n        require(baseToken == address(0), 'INITIALIZED');\n        require(_baseToken != address(0), 'ADDRESS_IS_ZERO');\n        baseToken = _baseToken;  // it should be tgas token address\n    }\n}"
    },
    "contracts/TomiDelegate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport './TomiLP.sol';\nimport './libraries/TransferHelper.sol';\nimport './libraries/SafeMath.sol';\nimport './modules/Ownable.sol';\nimport './interfaces/ITomiEscrow.sol';\n\ninterface ITomiLP {\n    function addLiquidity(\n        address user,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 deadline) external returns (\n            uint256 _amountA,\n            uint256 _amountB,\n            uint256 _liquidity\n        );\n    function removeLiquidity(\n        address user,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 deadline) external returns (\n            uint256 _amountA,\n            uint256 _amountB\n        );\n    function addLiquidityETH(\n        address user,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        uint256 deadline) external payable returns (\n            uint256 _amountToken,\n            uint256 _amountETH,\n            uint256 _liquidity\n        );\n    function removeLiquidityETH (\n        address user,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        uint256 deadline) external returns (uint256 _amountToken, uint256 _amountETH);\n    function initialize(address _tokenA, address _tokenB, address _DGAS, address _POOL, address _PLATFORM, address _WETH, address _DELEGATE) external;\n    function upgrade(address _PLATFORM) external;\n    function tokenA() external returns(address);\n    function mintRewardForUser(address _userAddress) external returns (uint rewardAmount);\n}\n\ncontract TomiDelegate is Ownable{\n    using SafeMath for uint;\n    \n    address public PLATFORM;\n    address public POOL;\n    address public TGAS;\n    address public WETH;\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n    mapping(address => bool) public isPair;\n    mapping(address => address[]) public playerPairs;\n    mapping(address => mapping(address => bool)) public isAddPlayerPair;\n\n    bytes32 public contractCodeHash;\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n    event RewardMinted(address indexed user, address indexed shareToken, uint amount);\n    \n    constructor(address _PLATFORM, address _POOL, address _TGAS, address _WETH) public {\n        PLATFORM = _PLATFORM;\n        POOL = _POOL;\n        TGAS = _TGAS;\n        WETH = _WETH;\n    }\n    \n    receive() external payable {\n    }\n    \n    function upgradePlatform(address _PLATFORM) external onlyOwner {\n        for(uint i = 0; i < allPairs.length;i++) {\n            ITomiLP(allPairs[i]).upgrade(_PLATFORM);\n        }\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function getPlayerPairCount(address player) external view returns (uint256) {\n        return playerPairs[player].length;\n    }\n\n    function _addPlayerPair(address _user, address _pair) internal {\n        if (isAddPlayerPair[_user][_pair] == false) {\n            isAddPlayerPair[_user][_pair] = true;\n            playerPairs[_user].push(_pair);\n        }\n    }\n\n    function addPlayerPair(address _user) external {\n        require(isPair[msg.sender], 'addPlayerPair Forbidden');\n        _addPlayerPair(_user, msg.sender);\n    }\n    \n    function approveContract(address token, address spender, uint amount) internal {\n        uint allowAmount = IERC20(token).totalSupply();\n        if(allowAmount < amount) {\n            allowAmount = amount;\n        }\n        if(IERC20(token).allowance(address(this), spender) < amount) {\n            TransferHelper.safeApprove(token, spender, allowAmount);\n        }\n    }\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        uint256 deadline\n        ) payable external returns (\n            uint256 _amountToken,\n            uint256 _amountETH,\n            uint256 _liquidity\n        ) {\n        address pair = getPair[token][WETH];\n            if(pair == address(0)) {\n                pair = _createPair(token, WETH);\n            }\n            \n            _addPlayerPair(msg.sender, pair);\n\n            TransferHelper.safeTransferFrom(token, msg.sender, address(this), amountTokenDesired);\n            // approveContract(token, pair, amountTokenDesired);\n            TransferHelper.safeApprove(token, pair, amountTokenDesired);\n            (_amountToken, _amountETH, _liquidity) = ITomiLP(pair).addLiquidityETH{value: msg.value}(msg.sender, amountTokenDesired, amountTokenMin, amountETHMin, deadline);\n    }\n    \n    \n    \n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 deadline) external returns (\n            uint256 _amountA,\n            uint256 _amountB,\n            uint256 _liquidity\n        ) {\n            address pair = getPair[tokenA][tokenB];\n            if(pair == address(0)) {\n                pair = _createPair(tokenA, tokenB);\n            }\n\n            _addPlayerPair(msg.sender, pair);\n\n            if(tokenA != ITomiLP(pair).tokenA()) {\n                (tokenA, tokenB) = (tokenB, tokenA);\n                (amountA, amountB, amountAMin, amountBMin) = (amountB, amountA, amountBMin, amountAMin);\n            }\n            \n            TransferHelper.safeTransferFrom(tokenA, msg.sender, address(this), amountA);\n            TransferHelper.safeTransferFrom(tokenB, msg.sender, address(this), amountB);\n            approveContract(tokenA, pair, amountA);\n            approveContract(tokenB, pair, amountB);\n\n            (_amountA, _amountB, _liquidity) = ITomiLP(pair).addLiquidity(msg.sender, amountA, amountB, amountAMin, amountBMin, deadline);\n            if(tokenA != ITomiLP(pair).tokenA()) {\n                (_amountA, _amountB) = (_amountB, _amountA);\n            }\n    }\n    \n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        uint deadline\n        ) external returns (uint _amountToken, uint _amountETH) {\n            address pair = getPair[token][WETH];\n            (_amountToken, _amountETH) = ITomiLP(pair).removeLiquidityETH(msg.sender, liquidity, amountTokenMin, amountETHMin, deadline);\n        }\n    \n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 deadline) external returns (\n            uint256 _amountA,\n            uint256 _amountB\n        ) {\n        address pair = getPair[tokenA][tokenB];\n        (_amountA, _amountB) = ITomiLP(pair).removeLiquidity(msg.sender, liquidity, amountAMin, amountBMin, deadline);\n    }\n\n    function _createPair(address tokenA, address tokenB) internal returns (address pair){\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'TOMI FACTORY: ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'TOMI FACTORY: PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(TomiLP).creationCode;\n        if (uint256(contractCodeHash) == 0) {\n            contractCodeHash = keccak256(bytecode);\n        }\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        isPair[pair] = true;\n        ITomiLP(pair).initialize(token0, token1, TGAS, POOL, PLATFORM, WETH, address(this));\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function mintRewardByPair(address _escrow, address _pair, address _tokenAddress) external returns(uint) {\n        uint amount = ITomiLP(_pair).mintRewardForUser(msg.sender);\n        require(amount > 0, \"TomiDelegate::Your reward is not enough to claim!\");\n        \n        TransferHelper.safeTransfer(TGAS, address(0), amount);\n        ITomiEscrow(_escrow).withdrawReward(_tokenAddress, amount, msg.sender);\n        emit RewardMinted(msg.sender, _tokenAddress, amount);\n\n        return amount;\n    }\n}"
    },
    "contracts/TomiLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport './libraries/SafeMath.sol';\nimport './modules/BaseShareField.sol';\n\ninterface ITomiPool {\n    function queryReward(address _pair, address _user) external view returns(uint);\n    function claimReward(address _pair, address _rewardToken) external;\n}\n\ninterface ITomiPair {\n    function queryReward() external view returns (uint256 rewardAmount, uint256 blockNumber);\n    function mintReward() external returns (uint256 userReward);\n}\n\ninterface ITomiDelegate {\n    function addPlayerPair(address _user) external;\n}\n\ninterface ITomiPlatform{\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 _amountA,\n            uint256 _amountB,\n            uint256 _liquidity\n        );\n        \n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 _amountToken,\n            uint256 _amountETH,\n            uint256 _liquidity\n        );\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n    \n    function pairFor(address tokenA, address tokenB) external view returns (address);\n}\n\ncontract TomiLP is BaseShareField {\n    // ERC20 Start\n    \n    using SafeMath for uint;\n\n    string public constant name = 'Tomi LP';\n    string public constant symbol = 'BLP';\n    uint8 public constant decimals = 18;\n    uint public totalSupply;\n    \n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    event Mint(address indexed user, uint amount);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    \n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n    \n    receive() external payable {\n    }\n    \n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        require(balanceOf[from] >= value, 'ERC20Token: INSUFFICIENT_BALANCE');\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        if (to == address(0)) { // burn\n            totalSupply = totalSupply.sub(value);\n        }\n\n        ITomiDelegate(owner).addPlayerPair(to);\n        _mintReward();\n        _decreaseProductivity(from, value);\n        _increaseProductivity(to, value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        require(allowance[from][msg.sender] >= value, 'ERC20Token: INSUFFICIENT_ALLOWANCE');\n        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        return true;\n    }    \n    \n    // ERC20 End\n    \n    \n    address public owner;\n    address public POOL;\n    address public PLATFORM;\n    address public tokenA;\n    address public tokenB;\n    address public WETH;\n    address public DELEGATE;\n    \n    event AddLiquidity (address indexed user, uint amountA, uint amountB, uint value);\n    event RemoveLiquidity (address indexed user, uint amountA, uint amountB, uint value);\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    function initialize(address _tokenA, address _tokenB, address _DGAS, address _POOL, address _PLATFORM, address _WETH, address _DELEGATE) external {\n        require(msg.sender == owner, \"Demax LP Forbidden\");\n        tokenA = _tokenA;\n        tokenB = _tokenB;\n        _setShareToken(_DGAS);\n        PLATFORM = _PLATFORM;\n        POOL = _POOL;\n        WETH = _WETH;\n        DELEGATE = _DELEGATE;\n    }\n \n    function upgrade(address _PLATFORM) external {\n        require(msg.sender == owner, \"Tomi LP Forbidden\");\n        PLATFORM = _PLATFORM;\n    }\n\n    function approveContract(address token, address spender, uint amount) internal {\n        uint allowAmount = IERC20(token).totalSupply();\n        if(allowAmount < amount) {\n            allowAmount = amount;\n        }\n        if(IERC20(token).allowance(address(this), spender) < amount) {\n            TransferHelper.safeApprove(token, spender, allowAmount);\n        }\n    }\n    \n    function addLiquidityETH(\n        address user,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        uint256 deadline) external payable returns (\n            uint256 _amountToken,\n            uint256 _amountETH,\n            uint256 _liquidity\n        ) {\n           require(msg.sender == owner, \"Tomi LP Forbidden\");\n           require(tokenA == WETH || tokenB == WETH, \"INVALID CALL\");\n           address token = tokenA == WETH ? tokenB: tokenA;\n           approveContract(token, PLATFORM, amountTokenDesired);\n           TransferHelper.safeTransferFrom(token, msg.sender, address(this), amountTokenDesired);\n           \n           (_amountToken, _amountETH, _liquidity) = ITomiPlatform(PLATFORM).addLiquidityETH{value: msg.value}(token, amountTokenDesired, amountTokenMin, amountETHMin, deadline);\n           \n           if(amountTokenDesired > _amountToken) {\n                TransferHelper.safeTransfer(token, user, amountTokenDesired.sub(_amountToken));\n            }\n            \n            if(msg.value > _amountETH) {\n                TransferHelper.safeTransferETH(user, msg.value.sub(_amountETH));\n            }\n        _mintReward();\n        _mint(user, _liquidity);\n        _increaseProductivity(user, _liquidity);\n        (uint amountA, uint amountB) = token == tokenA ? (_amountToken, _amountETH): (_amountETH, _amountToken);\n        emit AddLiquidity (user, amountA, amountB, _liquidity);\n    }\n    \n    function addLiquidity(\n        address user,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 deadline) external returns (\n            uint256 _amountA,\n            uint256 _amountB,\n            uint256 _liquidity\n        ) {\n            require(msg.sender == owner, \"Tomi LP Forbidden\");\n            approveContract(tokenA, PLATFORM, amountA);\n            approveContract(tokenB, PLATFORM, amountB);\n            TransferHelper.safeTransferFrom(tokenA, msg.sender, address(this), amountA);\n            TransferHelper.safeTransferFrom(tokenB, msg.sender, address(this), amountB);\n        (_amountA, _amountB, _liquidity) = ITomiPlatform(PLATFORM).addLiquidity(tokenA, tokenB, amountA, amountB, amountAMin, amountBMin, deadline);\n        if(amountA > _amountA) {\n            TransferHelper.safeTransfer(tokenA, user, amountA.sub(_amountA));\n        }\n        \n        if(amountB > _amountB) {\n            TransferHelper.safeTransfer(tokenB, user, amountB.sub(_amountB));\n        }\n        \n        _mintReward();\n        _mint(user, _liquidity);\n        _increaseProductivity(user, _liquidity);\n        emit AddLiquidity (user, _amountA, _amountB, _liquidity);\n    }\n    \n    function removeLiquidityETH (\n        address user,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        uint256 deadline) external returns (uint256 _amountToken, uint256 _amountETH) {\n         require(msg.sender == owner, \"Tomi LP Forbidden\");\n         require(tokenA == WETH || tokenB == WETH, \"INVALID CALL\");\n         address token = tokenA == WETH ? tokenB: tokenA;\n           \n        (_amountToken, _amountETH) = ITomiPlatform(PLATFORM).removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, user, deadline);\n         \n        _mintReward();\n        _burn(user, liquidity);\n        _decreaseProductivity(user, liquidity);\n        (uint amountA, uint amountB) = token == tokenA ? (_amountToken, _amountETH): (_amountETH, _amountToken);\n        emit RemoveLiquidity (user, amountA, amountB, liquidity);\n    }\n    \n    function removeLiquidity(\n        address user,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 deadline) external returns (\n            uint256 _amountA,\n            uint256 _amountB\n        ) {\n            require(msg.sender == owner, \"Tomi LP Forbidden\");\n        (_amountA, _amountB) = ITomiPlatform(PLATFORM).removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, user, deadline);\n        \n        _mintReward();\n        _burn(user, liquidity);\n        _decreaseProductivity(user, liquidity);\n        emit RemoveLiquidity (user, _amountA, _amountB, liquidity);\n    }\n    \n    function _currentReward() internal override view returns (uint) {\n        address pair = ITomiPlatform(PLATFORM).pairFor(tokenA, tokenB);\n        uint countractAmount = mintedShare.add(IERC20(shareToken).balanceOf(address(this))).sub(totalShare);\n        if(pair != address(0)) {\n            uint poolAmount = ITomiPool(POOL).queryReward(pair, address(this));\n            (uint pairAmount, ) = ITomiPair(pair).queryReward();\n            return countractAmount.add(poolAmount).add(pairAmount);\n        } else {\n            return countractAmount;\n        }\n    }\n    \n    function _mintReward() internal {\n        address pair = ITomiPlatform(PLATFORM).pairFor(tokenA, tokenB);\n        if(pair != address(0)) {\n            uint poolAmount = ITomiPool(POOL).queryReward(pair, address(this));\n            (uint pairAmount, ) = ITomiPair(pair).queryReward();\n            if(poolAmount > 0) {\n                ITomiPool(POOL).claimReward(pair, shareToken);\n            }\n            \n            if(pairAmount > 0) {\n                ITomiPair(pair).mintReward();\n            }\n        } \n    }\n    \n    function queryReward() external view returns (uint) {\n        return _takeWithAddress(msg.sender);\n    }\n    \n\n    function mintRewardForUser(address _userAddress) external returns (uint amount) {\n        require(msg.sender == DELEGATE, \"TomiPair::Your permission not be able to do!\");\n        _mintReward();\n        amount = _mint(_userAddress);\n        emit Mint(msg.sender, amount);\n    }\n}"
    },
    "contracts/interfaces/ITomiEscrow.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface ITomiEscrow {\n    function setShareToken(address _tokenAddress, uint _dgasRate) external;\n    function depositReward(address _tokenAddress, uint _reward) external;\n    function withdrawReward(address _shareToken, uint _amount, address _to) external;\n    function updateShareTokenRate(address _tokenAddress, uint _dgasRate) external;\n    function shareTokenExisted(address _tokenAddress) external view returns(bool);\n    function shareTokenReward(address _tokenAddress) external view returns(uint);\n}\n\n"
    },
    "contracts/modules/BaseShareField.sol": {
      "content": "pragma solidity >=0.6.6;\nimport '../interfaces/ERC2917-Interface.sol';\nimport '../libraries/SafeMath.sol';\nimport '../libraries/TransferHelper.sol';\n\ncontract BaseShareField {\n    using SafeMath for uint;\n    \n    uint totalProductivity;\n    uint accAmountPerShare;\n    \n    uint public totalShare;\n    uint public mintedShare;\n    uint public mintCumulation;\n    \n    address public shareToken;\n    \n    struct UserInfo {\n        uint amount;     // How many tokens the user has provided.\n        uint rewardDebt; // Reward debt. \n        uint rewardEarn; // Reward earn and not minted\n    }\n\n    mapping(address => UserInfo) public users;\n    \n    function _setShareToken(address _shareToken) internal {\n        shareToken = _shareToken;\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function _update() internal virtual {\n        if (totalProductivity == 0) {\n            totalShare = totalShare.add(_currentReward());\n            return;\n        }\n        \n        uint256 reward = _currentReward();\n        accAmountPerShare = accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\n        totalShare = totalShare.add(reward);\n    }\n    \n    function _currentReward() internal virtual view returns (uint) {\n        return mintedShare.add(IERC20(shareToken).balanceOf(address(this))).sub(totalShare);\n    }\n    \n    // Audit user's reward to be up-to-date\n    function _audit(address user) internal virtual {\n        UserInfo storage userInfo = users[user];\n        if (userInfo.amount > 0) {\n            uint pending = userInfo.amount.mul(accAmountPerShare).div(1e12).sub(userInfo.rewardDebt);\n            userInfo.rewardEarn = userInfo.rewardEarn.add(pending);\n            mintCumulation = mintCumulation.add(pending);\n            userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\n        }\n    }\n\n    // External function call\n    // This function increase user's productivity and updates the global productivity.\n    // the users' actual share percentage will calculated by:\n    // Formula:     user_productivity / global_productivity\n    function _increaseProductivity(address user, uint value) internal virtual returns (bool) {\n        require(value > 0, 'PRODUCTIVITY_VALUE_MUST_BE_GREATER_THAN_ZERO');\n\n        UserInfo storage userInfo = users[user];\n        _update();\n        _audit(user);\n\n        totalProductivity = totalProductivity.add(value);\n\n        userInfo.amount = userInfo.amount.add(value);\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\n        return true;\n    }\n\n    // External function call \n    // This function will decreases user's productivity by value, and updates the global productivity\n    // it will record which block this is happenning and accumulates the area of (productivity * time)\n    function _decreaseProductivity(address user, uint value) internal virtual returns (bool) {\n        UserInfo storage userInfo = users[user];\n        require(value > 0 && userInfo.amount >= value, 'INSUFFICIENT_PRODUCTIVITY');\n        \n        _update();\n        _audit(user);\n        \n        userInfo.amount = userInfo.amount.sub(value);\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\n        totalProductivity = totalProductivity.sub(value);\n        \n        return true;\n    }\n    \n    function _takeWithAddress(address user) internal view returns (uint) {\n        UserInfo storage userInfo = users[user];\n        uint _accAmountPerShare = accAmountPerShare;\n        // uint256 lpSupply = totalProductivity;\n        if (totalProductivity != 0) {\n            uint reward = _currentReward();\n            _accAmountPerShare = _accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\n        }\n        return userInfo.amount.mul(_accAmountPerShare).div(1e12).add(userInfo.rewardEarn).sub(userInfo.rewardDebt);\n    }\n\n    // External function call\n    // When user calls this function, it will calculate how many token will mint to user from his productivity * time\n    // Also it calculates global token supply from last time the user mint to this time.\n    function _mint(address user) internal virtual returns (uint) {\n        _update();\n        _audit(user);\n        require(users[user].rewardEarn > 0, \"NOTHING TO MINT\");\n        uint amount = users[user].rewardEarn;\n        TransferHelper.safeTransfer(shareToken, msg.sender, amount);\n        users[user].rewardEarn = 0;\n        mintedShare += amount;\n        return amount;\n    }\n\n    // Returns how many productivity a user has and global has.\n    function getProductivity(address user) public virtual view returns (uint, uint) {\n        return (users[user].amount, totalProductivity);\n    }\n\n    // Returns the current gorss product rate.\n    function interestsPerBlock() public virtual view returns (uint) {\n        return accAmountPerShare;\n    }\n    \n}"
    },
    "contracts/interfaces/ERC2917-Interface.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\nimport '../interfaces/IERC20.sol';\n\ninterface IERC2917 is IERC20 {\n\n    /// @dev This emit when interests amount per block is changed by the owner of the contract.\n    /// It emits with the old interests amount and the new interests amount.\n    event InterestRatePerBlockChanged (uint oldValue, uint newValue);\n\n    /// @dev This emit when a users' productivity has changed\n    /// It emits with the user's address and the the value after the change.\n    event ProductivityIncreased (address indexed user, uint value);\n\n    /// @dev This emit when a users' productivity has changed\n    /// It emits with the user's address and the the value after the change.\n    event ProductivityDecreased (address indexed user, uint value);\n\n    /// @dev Return the current contract's interests rate per block.\n    /// @return The amount of interests currently producing per each block.\n    function interestsPerBlock() external view returns (uint);\n\n    /// @notice Change the current contract's interests rate.\n    /// @dev Note the best practice will be restrict the gross product provider's contract address to call this.\n    /// @return The true/fase to notice that the value has successfully changed or not, when it succeed, it will emite the InterestRatePerBlockChanged event.\n    function changeInterestRatePerBlock(uint value) external returns (bool);\n\n    /// @notice It will get the productivity of given user.\n    /// @dev it will return 0 if user has no productivity proved in the contract.\n    /// @return user's productivity and overall productivity.\n    function getProductivity(address user) external view returns (uint, uint);\n\n    /// @notice increase a user's productivity.\n    /// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\n    /// @return true to confirm that the productivity added success.\n    function increaseProductivity(address user, uint value) external returns (bool);\n\n    /// @notice decrease a user's productivity.\n    /// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\n    /// @return true to confirm that the productivity removed success.\n    function decreaseProductivity(address user, uint value) external returns (bool);\n\n    /// @notice take() will return the interests that callee will get at current block height.\n    /// @dev it will always calculated by block.number, so it will change when block height changes.\n    /// @return amount of the interests that user are able to mint() at current block height.\n    function take() external view returns (uint);\n\n    /// @notice similar to take(), but with the block height joined to calculate return.\n    /// @dev for instance, it returns (_amount, _block), which means at block height _block, the callee has accumulated _amount of interests.\n    /// @return amount of interests and the block height.\n    function takeWithBlock() external view returns (uint, uint);\n\n    /// @notice mint the avaiable interests to callee.\n    /// @dev once it mint, the amount of interests will transfer to callee's address.\n    /// @return the amount of interests minted.\n    function mint() external returns (uint);\n}\n"
    },
    "contracts/TomiEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport \"./modules/Upgradable.sol\";\nimport './libraries/SafeMath.sol';\nimport './libraries/TransferHelper.sol';\nimport './interfaces/IERC20.sol';\n\ncontract TomiEscrow is UpgradableProduct {\n    using SafeMath for uint;\n\n    struct ShareToken {\n        uint dgasRate;\n        uint totalReward;\n    }\n\n    address public DELEGATE;\n\n    mapping(address => ShareToken) public shareTokens;\n\n    event RewardDeposited(address shareToken, uint reward, uint totalReward);\n    event RewardWithdraw(address shareToken, uint reward, address to);\n    event DgasToTokenRated(uint oldRate, uint newRate);\n    event ShareTokenUpdated(address tokenAddress, uint dgasRate);\n    event ShareTokenSettled(address tokenAddress, uint dgasRate);\n\n    constructor(address _DELEGATE) UpgradableProduct() public {\n        DELEGATE = _DELEGATE;\n    }\n\n    modifier onlyDelegate() {\n        require(msg.sender == DELEGATE, \"TomiEscrow::FORBIDDEN\");\n        _;\n    }\n\n    function setShareToken(address _tokenAddress, uint _dgasRate) public requireImpl {\n        require(!shareTokenExisted(_tokenAddress), \"TomiEscrow::Share token address already exist!\");\n        require(_tokenAddress != address(0), \"TomiEscrow::Share token address is not illegal\");\n        require(_dgasRate != uint(0), \"TomiEscrow::Share token rate is not illegal\");\n        shareTokens[_tokenAddress] = ShareToken(_dgasRate, uint(0));\n\n        emit ShareTokenSettled(_tokenAddress, _dgasRate);\n    }\n\n\n    function depositReward(address _tokenAddress, uint _reward) public requireImpl {\n        require(shareTokenExisted(_tokenAddress), \"DemaxEscrow::Share token not existed!\");\n        uint allowance = IERC20(_tokenAddress).allowance(impl, address(this));\n        require(allowance >= _reward, \"DemaxEscrow::Allowance is less than desired reward!\");\n        \n        TransferHelper.safeTransferFrom(_tokenAddress, impl, address(this), _reward);\n        \n        uint totalReward = shareTokenReward(_tokenAddress);\n        totalReward = totalReward.add(_reward);\n\n        _updateShareTokenReward(_tokenAddress, totalReward);\n        emit RewardDeposited(_tokenAddress, _reward, totalReward);\n    }\n\n    function withdrawReward(address _tokenAddress, uint _amount, address _to) public onlyDelegate {\n        require(shareTokenExisted(_tokenAddress), \"DemaxEscrow::Share token not existed!\");\n        uint totalReward = shareTokenReward(_tokenAddress);\n        uint DGasToToken = shareTokens[_tokenAddress].dgasRate;\n        \n        require(totalReward >= _amount, \"DemaxEscrow::Not enough rewards for withdraw!\");\n        \n        uint dgasToReward = _amount.mul(DGasToToken);\n        TransferHelper.safeTransfer(_tokenAddress, _to, dgasToReward);\n        totalReward = totalReward.sub(dgasToReward);\n\n        _updateShareTokenReward(_tokenAddress, totalReward);\n        emit RewardWithdraw(_tokenAddress, dgasToReward, _to);\n    }\n\n    function updateShareTokenRate(address _tokenAddress, uint _dgasRate) public requireImpl {\n        require(shareTokenExisted(_tokenAddress), \"DemaxEscrow::Share token not existed!\");\n        require(_dgasRate != uint(0), \"DemaxEscrow::Share token rate is not illegal\");\n        require( shareTokens[_tokenAddress].dgasRate != _dgasRate, \"DemaxEscrow::Not be able to set same Dgas rate!\");\n\n        shareTokens[_tokenAddress].dgasRate = _dgasRate;\n\n        emit ShareTokenUpdated(_tokenAddress, _dgasRate);\n    }\n\n    function shareTokenExisted(address _tokenAddress) public view returns(bool) {\n        require(_tokenAddress != address(0), \"DemaxEscrow::Share token address is illegal\");\n        return shareTokens[_tokenAddress].dgasRate != uint(0);\n    }\n\n    function shareTokenReward(address _tokenAddress) public view returns(uint) {\n        return shareTokens[_tokenAddress].totalReward;\n    }\n\n    function _updateShareTokenReward(address _tokenAddress, uint _newReward) private {\n        require(shareTokenExisted(_tokenAddress), \"DemaxEscrow::Share token not existed!\");\n        shareTokens[_tokenAddress].totalReward = _newReward;\n    }\n\n}\n"
    },
    "contracts/modules/Upgradable.sol": {
      "content": "pragma solidity >=0.5.16;\n\ncontract UpgradableProduct {\n    address public impl;\n\n    event ImplChanged(address indexed _oldImpl, address indexed _newImpl);\n\n    constructor() public {\n        impl = msg.sender;\n    }\n\n    modifier requireImpl() {\n        require(msg.sender == impl, 'FORBIDDEN');\n        _;\n    }\n\n    function upgradeImpl(address _newImpl) public requireImpl {\n        require(_newImpl != address(0), 'INVALID_ADDRESS');\n        require(_newImpl != impl, 'NO_CHANGE');\n        address lastImpl = impl;\n        impl = _newImpl;\n        emit ImplChanged(lastImpl, _newImpl);\n    }\n}\n\ncontract UpgradableGovernance {\n    address public governor;\n\n    event GovernorChanged(address indexed _oldGovernor, address indexed _newGovernor);\n\n    constructor() public {\n        governor = msg.sender;\n    }\n\n    modifier requireGovernor() {\n        require(msg.sender == governor, 'FORBIDDEN');\n        _;\n    }\n\n    function upgradeGovernance(address _newGovernor) public requireGovernor {\n        require(_newGovernor != address(0), 'INVALID_ADDRESS');\n        require(_newGovernor != governor, 'NO_CHANGE');\n        address lastGovernor = governor;\n        governor = _newGovernor;\n        emit GovernorChanged(lastGovernor, _newGovernor);\n    }\n}"
    },
    "contracts/modules/ERC2917Impl.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport '../interfaces/ERC2917-Interface.sol';\nimport '../modules/Upgradable.sol';\nimport '../libraries/SafeMath.sol';\n\n/*\n    The Objective of ERC2917 Demo is to implement a decentralized staking mechanism, which calculates users' share\n    by accumulating productiviy * time. And calculates users revenue from anytime t0 to t1 by the formula below:\n\n        user_accumulated_productivity(time1) - user_accumulated_productivity(time0)\n       _____________________________________________________________________________  * (gross_product(t1) - gross_product(t0))\n       total_accumulated_productivity(time1) - total_accumulated_productivity(time0)\n\n*/\ncontract ERC2917Impl is IERC2917, UpgradableProduct, UpgradableGovernance {\n    using SafeMath for uint;\n\n    uint public mintCumulation;\n    uint public amountPerBlock;\n\n    uint public nounce;\n\n    function incNounce() public {\n        nounce ++;\n    }\n\n    // implementation of ERC20 interfaces.\n    string override public name;\n    string override public symbol;\n    uint8 override public decimals = 18;\n    uint override public totalSupply;\n\n    mapping(address => uint) override public balanceOf;\n    mapping(address => mapping(address => uint)) override public allowance;\n\n    function _transfer(address from, address to, uint value) internal virtual {\n        require(balanceOf[from] >= value, 'ERC20Token: INSUFFICIENT_BALANCE');\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        if (to == address(0)) { // burn\n            totalSupply = totalSupply.sub(value);\n        }\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external virtual override  returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external virtual override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external virtual override returns (bool) {\n        require(allowance[from][msg.sender] >= value, 'ERC20Token: INSUFFICIENT_ALLOWANCE');\n        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    // end of implementation of ERC20\n    \n    uint lastRewardBlock;\n    uint totalProductivity;\n    uint accAmountPerShare;\n    struct UserInfo {\n        uint amount;     // How many LP tokens the user has provided.\n        uint rewardDebt; // Reward debt. \n        uint rewardEarn; // Reward earn and not minted\n    }\n\n    mapping(address => UserInfo) public users;\n\n    // creation of the interests token.\n    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint _interestsRate) UpgradableProduct() UpgradableGovernance() public {\n        name        = _name;\n        symbol      = _symbol;\n        decimals    = _decimals;\n\n        amountPerBlock = _interestsRate;\n    }\n\n    // External function call\n    // This function adjust how many token will be produced by each block, eg:\n    // changeAmountPerBlock(100)\n    // will set the produce rate to 100/block.\n    function changeInterestRatePerBlock(uint value) external virtual override requireGovernor returns (bool) {\n        uint old = amountPerBlock;\n        require(value != old, 'AMOUNT_PER_BLOCK_NO_CHANGE');\n\n        _update();\n        amountPerBlock = value;\n\n        emit InterestRatePerBlockChanged(old, value);\n        return true;\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function _update() internal virtual {\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n\n        if (totalProductivity == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n        \n        uint256 reward = _currentReward();\n        balanceOf[address(this)] = balanceOf[address(this)].add(reward);\n        totalSupply = totalSupply.add(reward);\n\n        accAmountPerShare = accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\n        lastRewardBlock = block.number;\n    }\n    \n    function _currentReward() internal virtual view returns (uint){\n        uint256 multiplier = block.number.sub(lastRewardBlock);\n        return multiplier.mul(amountPerBlock);\n    }\n    \n    // Audit user's reward to be up-to-date\n    function _audit(address user) internal virtual {\n        UserInfo storage userInfo = users[user];\n        if (userInfo.amount > 0) {\n            uint pending = userInfo.amount.mul(accAmountPerShare).div(1e12).sub(userInfo.rewardDebt);\n            userInfo.rewardEarn = userInfo.rewardEarn.add(pending);\n            mintCumulation = mintCumulation.add(pending);\n            userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\n        }\n    }\n\n    // External function call\n    // This function increase user's productivity and updates the global productivity.\n    // the users' actual share percentage will calculated by:\n    // Formula:     user_productivity / global_productivity\n    function increaseProductivity(address user, uint value) external virtual override requireImpl returns (bool) {\n        require(value > 0, 'PRODUCTIVITY_VALUE_MUST_BE_GREATER_THAN_ZERO');\n\n        UserInfo storage userInfo = users[user];\n        _update();\n        _audit(user);\n\n        totalProductivity = totalProductivity.add(value);\n\n        userInfo.amount = userInfo.amount.add(value);\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\n        emit ProductivityIncreased(user, value);\n        return true;\n    }\n\n    // External function call \n    // This function will decreases user's productivity by value, and updates the global productivity\n    // it will record which block this is happenning and accumulates the area of (productivity * time)\n    function decreaseProductivity(address user, uint value) external virtual override requireImpl returns (bool) {\n        UserInfo storage userInfo = users[user];\n        require(value > 0 && userInfo.amount >= value, \"INSUFFICIENT_PRODUCTIVITY\");\n        _update();\n        _audit(user);\n        \n        userInfo.amount = userInfo.amount.sub(value);\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\n        totalProductivity = totalProductivity.sub(value);\n\n        emit ProductivityDecreased(user, value);\n        return true;\n    }\n    \n    function takeWithAddress(address user) public view returns (uint) {\n        UserInfo storage userInfo = users[user];\n        uint _accAmountPerShare = accAmountPerShare;\n        // uint256 lpSupply = totalProductivity;\n        if (block.number > lastRewardBlock && totalProductivity != 0) {\n            uint reward = _currentReward();\n            _accAmountPerShare = _accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\n        }\n        return userInfo.amount.mul(_accAmountPerShare).div(1e12).sub(userInfo.rewardDebt).add(userInfo.rewardEarn);\n    }\n\n    function take() external override virtual view returns (uint) {\n        return takeWithAddress(msg.sender);\n    }\n\n    // Returns how much a user could earn plus the giving block number.\n    function takeWithBlock() external override virtual view returns (uint, uint) {\n        uint earn = takeWithAddress(msg.sender);\n        return (earn, block.number);\n    }\n\n\n    // External function call\n    // When user calls this function, it will calculate how many token will mint to user from his productivity * time\n    // Also it calculates global token supply from last time the user mint to this time.\n    function mint() external override virtual returns (uint) {\n        _update();\n        _audit(msg.sender);\n        require(users[msg.sender].rewardEarn > 0, \"NO_PRODUCTIVITY\");\n        uint amount = users[msg.sender].rewardEarn;\n        _transfer(address(this), msg.sender, users[msg.sender].rewardEarn);\n        users[msg.sender].rewardEarn = 0;\n        return amount;\n    }\n\n    // Returns how many productivity a user has and global has.\n    function getProductivity(address user) external override virtual view returns (uint, uint) {\n        return (users[user].amount, totalProductivity);\n    }\n\n    // Returns the current gorss product rate.\n    function interestsPerBlock() external override virtual view returns (uint) {\n        return accAmountPerShare;\n    }\n}"
    },
    "contracts/Tgas.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\n\nimport './modules/ERC2917Impl.sol';\n\ncontract Tgas is ERC2917Impl(\"Tomi Swap\", \"TOMI\", 18, 40 * (10 ** 18)) {\n    // TOMI TEST ONLY\n\tconstructor() public {\n        totalSupply += 1000000000* 10 ** 18;\n        balanceOf[msg.sender] = 1000000000* 10 ** 18;   \n    }\n}"
    },
    "contracts/test/TgasTest.sol": {
      "content": "pragma solidity >=0.5.16;\n\nimport '../modules/ERC2917Impl.sol';\n\ncontract TgasTest is ERC2917Impl(\"Demax Gas\", \"DGAS\", 18, 1 * (10 ** 18)) {\n\n    constructor() public {\n        totalSupply += 1000000000000000* 10 ** 18;\n        balanceOf[msg.sender] = 1000000000000000* 10 ** 18;   \n    }\n}\n"
    },
    "contracts/TomiPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport './libraries/Math.sol';\nimport './libraries/UQ112x112.sol';\nimport './interfaces/ITomiFactory.sol';\nimport './interfaces/ITgas.sol';\nimport './interfaces/ITomiCallee.sol';\nimport './interfaces/ITomiConfig.sol';\nimport './modules/BaseShareField.sol';\nimport './libraries/ConfigNames.sol';\n\ncontract TomiPair is BaseShareField {\n    uint256 public version = 1;\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public FACTORY;\n    address public CONFIG;\n    address public TGAS;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n\n    uint256 public totalReward;\n    uint256 public remainReward;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    event Mint(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, address indexed to, uint256 value);\n    event MintTGAS(address indexed player, uint256 pairMint, uint256 userMint);\n    mapping(address => uint256) public lastMintBlock;\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'Locked');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Mint(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Burn(from, address(0), value);\n    }\n    \n    function _mintTGAS() internal {\n        if(ITgas(TGAS).take() > 0) {\n            uint reward = ITgas(TGAS).mint();\n            uint devAmount = reward * ITomiConfig(CONFIG).getConfigValue(ConfigNames.DEV_PRECENT) / 10000;\n            address devAddress = ITomiConfig(CONFIG).dev();\n            _safeTransfer(TGAS, devAddress, devAmount);\n            remainReward = remainReward.add(reward.sub(devAmount));\n        }\n    }\n    \n    function _currentReward() internal override view returns (uint) {\n        uint devPercent = ITomiConfig(CONFIG).getConfigValue(ConfigNames.DEV_PRECENT);\n        uint pairReward = ITgas(TGAS).take().mul(10000 - devPercent).div(10000);\n        return mintedShare.add(remainReward).add(pairReward).sub(totalShare);\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TOMI PAIR : TRANSFER_FAILED');\n    }\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event SwapFee(address indexed token, address indexed to, uint256 amount);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() public {\n        FACTORY = msg.sender;\n    }\n\n    modifier onlyPlatform {\n        address platform = ITomiConfig(CONFIG).platform();\n        require(msg.sender == platform, 'TOMI PAIR : FORBIDDEN');\n        _;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        address _token0,\n        address _token1,\n        address _config,\n        address _tgas\n    ) external {\n        require(msg.sender == FACTORY, 'TOMI PAIR : FORBIDDEN');\n        token0 = _token0;\n        token1 = _token1;\n        CONFIG = _config;\n        TGAS = _tgas;\n        _setShareToken(TGAS);\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'TOMI PAIR : OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // this low-level function should be called from a contract which performs // important safety checks\n    function mint(address to) external onlyPlatform lock returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint256 balance0 = _balanceOf(token0, address(this));\n        uint256 balance1 = _balanceOf(token1, address(this));\n        uint256 amount0 = balance0.sub(_reserve0);\n        uint256 amount1 = balance1.sub(_reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, 'TOMI PAIR : INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n        _mintTGAS();\n        _increaseProductivity(to, liquidity);\n        lastMintBlock[to] = block.number;\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs // important safety checks\n    function burn(\n        address from,\n        address to,\n        uint256 amount\n    ) external onlyPlatform lock returns (uint256 amount0, uint256 amount1) {\n        require(\n            block.number >=\n                lastMintBlock[from] + ITomiConfig(CONFIG).getConfigValue(ConfigNames.REMOVE_LIQUIDITY_DURATION),\n            'TOMI PLATFORM : REMOVE LIQUIDITY DURATION FAIL'\n        );\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = _balanceOf(_token0, address(this));\n        uint256 balance1 = _balanceOf(_token1, address(this));\n        require(balanceOf[from] >= amount, 'TOMI PAIR : INSUFFICIENT_LIQUIDITY_AMOUNT');\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = amount.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = amount.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, 'TOMI PAIR : INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(from, amount);\n        _mintTGAS();\n        _decreaseProductivity(from, amount);\n\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = _balanceOf(_token0, address(this));\n        balance1 = _balanceOf(_token1, address(this));\n        _update(balance0, balance1, _reserve0, _reserve1);\n\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs // important safety checks\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external onlyPlatform lock {\n        require(amount0Out > 0 || amount1Out > 0, 'TOMI PAIR : INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'TOMI PAIR :  INSUFFICIENT_LIQUIDITY');\n        uint256 balance0;\n        uint256 balance1;\n        {\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, 'TOMI PAIR : INVALID_TO');\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);\n            if (data.length > 0) ITomiCallee(to).tomiCall(msg.sender, amount0Out, amount1Out, data);\n            balance0 = _balanceOf(_token0, address(this));\n            balance1 = _balanceOf(_token1, address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        uint256 _amount0Out = amount0Out;\n        uint256 _amount1Out = amount1Out;\n        require(amount0In > 0 || amount1In > 0, 'TOMI PAIR : INSUFFICIENT_INPUT_AMOUNT');\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, _amount0Out, _amount1Out, to);\n    }\n\n    function swapFee(\n        uint256 amount,\n        address token,\n        address to\n    ) external onlyPlatform {\n        if (amount == 0 || token == to) return;\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves();\n        require(to != token0 && to != token1, 'TOMI PAIR : INVALID_TO');\n        _safeTransfer(token, to, amount);\n        uint256 balance0 = _balanceOf(token0, address(this));\n        uint256 balance1 = _balanceOf(token1, address(this));\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit SwapFee(token, to , amount);\n    }\n\n    function queryReward() external view returns (uint256 rewardAmount, uint256 blockNumber) {\n        rewardAmount = _takeWithAddress(msg.sender);\n        blockNumber = block.number;\n    }\n\n    function mintReward() external lock returns (uint256 userReward) {\n        _mintTGAS();\n        userReward = _mint(msg.sender);\n        remainReward = remainReward.sub(userReward);\n        emit MintTGAS(msg.sender, remainReward, userReward);\n    }\n\n    function getTGASReserve() public view returns (uint256) {\n        return _balanceOf(TGAS, address(this));\n    }\n\n    function _balanceOf(address token, address owner) internal view returns (uint256) {\n        if (token == TGAS && owner == address(this)) {\n            return IERC20(token).balanceOf(owner).sub(remainReward);\n        } else {\n            return IERC20(token).balanceOf(owner);\n        }\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(_balanceOf(token0, address(this)), _balanceOf(token1, address(this)), reserve0, reserve1);\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "pragma solidity >=0.5.0;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "pragma solidity >=0.5.0;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}"
    },
    "contracts/interfaces/ITomiCallee.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface ITomiCallee {\n    function tomiCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}"
    },
    "contracts/TomiConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport './libraries/ConfigNames.sol';\nimport './libraries/TransferHelper.sol';\nimport './modules/TokenRegistry.sol';\nimport './modules/Ownable.sol';\n\ncontract TomiConfig is TokenRegistry, Ownable {\n    uint public version = 1;\n    event ConfigValueChanged(bytes32 _name, uint _old, uint _value);\n\n    struct Config {\n        uint minValue;\n        uint maxValue;\n        uint maxSpan;\n        uint value;\n        uint enable;  // 0:disable, 1: enable\n    }\n\n    mapping(bytes32 => Config) public configs;\n    address public tgas;                                // TGAS contract address\n    address public platform;      \n    address public dev;                         \n    uint public constant PERCENT_DENOMINATOR = 10000;\n    uint public constant TGAS_DECIMAL = 10 ** 18;\n    address[] public defaultListTokens;\n\n    modifier onlyPlatform() {\n        require(msg.sender == platform, 'TomiConfig: ONLY_PLATFORM');\n        _;\n    }\n\n    constructor()  public {\n        _initConfig(ConfigNames.PRODUCE_TGAS_RATE, 1 * TGAS_DECIMAL, 120 * TGAS_DECIMAL, 10 * TGAS_DECIMAL, 40 * TGAS_DECIMAL);\n        _initConfig(ConfigNames.SWAP_FEE_PERCENT, 5,30,5,30);\n        _initConfig(ConfigNames.LIST_TGAS_AMOUNT, 0, 100000 * TGAS_DECIMAL, 1000 * TGAS_DECIMAL, 0);\n        _initConfig(ConfigNames.UNSTAKE_DURATION, 17280, 17280*7, 17280, 17280);\n        _initConfig(ConfigNames.REMOVE_LIQUIDITY_DURATION, 0, 17280*7, 17280, 0);\n        _initConfig(ConfigNames.TOKEN_TO_TGAS_PAIR_MIN_PERCENT, 20, 500, 10, 100);\n        _initConfig(ConfigNames.LIST_TOKEN_FAILURE_BURN_PRECENT, 100, 5000, 500, 1000);\n        _initConfig(ConfigNames.LIST_TOKEN_SUCCESS_BURN_PRECENT, 1000, 5000, 500, 5000);\n        _initConfig(ConfigNames.PROPOSAL_TGAS_AMOUNT, 100 * TGAS_DECIMAL, 10000 * TGAS_DECIMAL, 100 * TGAS_DECIMAL, 100 * TGAS_DECIMAL);\n        _initConfig(ConfigNames.VOTE_DURATION, 17280, 17280*7, 17280, 17280);\n        _initConfig(ConfigNames.VOTE_REWARD_PERCENT, 0, 1000, 100, 500);\n        _initConfig(ConfigNames.TOKEN_PENGDING_SWITCH, 0, 1, 1, 1);  // 0:off, 1:on\n        _initConfig(ConfigNames.TOKEN_PENGDING_TIME, 0, 100*17280, 10*17280, 100*17280);\n        _initConfig(ConfigNames.LIST_TOKEN_SWITCH, 0, 1, 1, 0);  // 0:off, 1:on\n        _initConfig(ConfigNames.DEV_PRECENT, 1000, 1000, 1000, 1000);\n\n                _initConfig(ConfigNames.DEV_PRECENT, 1000, 1000, 1000, 1000);\n\n        _initConfig(ConfigNames.FEE_FUNDME_REWARD_PERCENT, 833, 833, 833, 833);  \n        _initConfig(ConfigNames.FEE_LOTTERY_REWARD_PERCENT, 833, 833, 833, 833);\n    }\n\n    function _initConfig(bytes32 _name, uint _minValue, uint _maxValue, uint _maxSpan, uint _value) internal {\n        Config storage config = configs[_name];\n        config.minValue = _minValue;\n        config.maxValue = _maxValue;\n        config.maxSpan = _maxSpan;\n        config.value = _value;\n        config.enable = 1;\n    }\n\n    function initialize(\n        address _tgas,\n        address _governor,\n        address _platform,\n        address _dev,\n        address[] memory _listTokens) public onlyOwner {\n        require(_tgas != address(0), \"TomiConfig: ZERO ADDRESS\");\n        tgas = _tgas;\n        platform = _platform;\n        dev = _dev;\n        for(uint i = 0 ; i < _listTokens.length; i++){\n            _updateToken(_listTokens[i], OPENED);\n            defaultListTokens.push(_listTokens[i]);\n        }\n        initGovernorAddress(_governor);\n    }\n\n    function modifyGovernor(address _new) public onlyOwner {\n        _changeGovernor(_new);\n    }\n\n    function modifyDev(address _new) public {\n        require(msg.sender == dev, 'TomiConfig: FORBIDDEN');\n        dev = _new;\n    }\n\n    function changeConfig(bytes32 _name, uint _minValue, uint _maxValue, uint _maxSpan, uint _value) external onlyOwner returns (bool) {\n        _initConfig(_name, _minValue, _maxValue, _maxSpan, _value);\n        return true;\n    }\n\n    function getConfig(bytes32 _name) external view returns (uint minValue, uint maxValue, uint maxSpan, uint value, uint enable) {\n        Config memory config = configs[_name];\n        minValue = config.minValue;\n        maxValue = config.maxValue;\n        maxSpan = config.maxSpan;\n        value = config.value;\n        enable = config.enable;\n    }\n    \n    function getConfigValue(bytes32 _name) public view returns (uint) {\n        return configs[_name].value;\n    }\n\n    function changeConfigValue(bytes32 _name, uint _value) external onlyGovernor returns (bool) {\n        Config storage config = configs[_name];\n        require(config.enable == 1, \"TomiConfig: DISABLE\");\n        require(_value <= config.maxValue && _value >= config.minValue, \"TomiConfig: OVERFLOW\");\n        uint old = config.value;\n        uint span = _value >= old ? (_value - old) : (old - _value);\n        require(span <= config.maxSpan, \"TomiConfig: EXCEED MAX ADJUST SPAN\");\n        config.value = _value;\n        emit ConfigValueChanged(_name, old, _value);\n        return true;\n    }\n\n    function checkToken(address _token) public view returns(bool) {\n        if (getConfigValue(ConfigNames.LIST_TOKEN_SWITCH) == 0) {\n            return true;\n        }\n        if (tokenStatus[_token] == OPENED) {\n            return true;\n        } else if (tokenStatus[_token] == PENDING ) {\n            if (getConfigValue(ConfigNames.TOKEN_PENGDING_SWITCH) == 1 && block.number > publishTime[_token] + getConfigValue(ConfigNames.TOKEN_PENGDING_TIME)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function checkPair(address tokenA, address tokenB) external view returns (bool) {\n        if (checkToken(tokenA) && checkToken(tokenB)) {\n            return true;\n        }\n        return false;\n    }\n\n    function getDefaultListTokens() external view returns (address[] memory) {\n        address[] memory res = new address[](defaultListTokens.length);\n        for (uint i; i < defaultListTokens.length; i++) {\n            res[i] = defaultListTokens[i];\n        }\n        return res;\n    }\n\n    function addToken(address _token) external onlyPlatform returns (bool) {\n        if(getConfigValue(ConfigNames.LIST_TOKEN_SWITCH) == 0) {\n            if(tokenStatus[_token] != OPENED) {\n                _updateToken(_token, OPENED);\n            }\n        }\n        return true;\n    }\n\n}"
    },
    "contracts/modules/TokenRegistry.sol": {
      "content": "pragma solidity >=0.5.16;\n\nimport './Governable.sol';\n\n/**\n    Business Process\n    step 1. publishToken\n    step 2. addToken or removeToken\n */\n\ncontract TokenRegistry is Governable {\n    mapping (address => uint) public tokenStatus;\n    mapping (address => uint) public publishTime;\n    uint public tokenCount;\n    address[] public tokenList;\n    uint public constant NONE = 0;\n    uint public constant REGISTERED = 1;\n    uint public constant PENDING = 2;\n    uint public constant OPENED = 3;\n    uint public constant CLOSED = 4;\n\n    event TokenStatusChanged(address indexed _token, uint _status, uint _block);\n\n    function registryToken(address _token) external onlyGovernor returns (bool) {\n        return _updateToken(_token, REGISTERED);\n    }\n\n    function publishToken(address _token) external onlyGovernor returns (bool) {\n        publishTime[_token] = block.number;\n        return _updateToken(_token, PENDING);\n    }\n\n    function updateToken(address _token, uint _status) external onlyGovernor returns (bool) {\n        return _updateToken(_token, _status);\n    }\n\n    function validTokens() external view returns (address[] memory) {\n        uint count;\n        for (uint i; i < tokenList.length; i++) {\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n                count++;\n            }\n        }\n        address[] memory res = new address[](count);\n        uint index = 0;\n        for (uint i; i < tokenList.length; i++) {\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n                res[index] = tokenList[i];\n                index++;\n            }\n        }\n        return res;\n    }\n\n    function iterateValidTokens(uint _start, uint _end) external view returns (address[] memory) {\n        require(_end <= tokenList.length, \"TokenRegistry: OVERFLOW\");\n        require(_start <= _end && _start >= 0 && _end >= 0, \"TokenRegistry: INVAID_PARAMTERS\");\n        uint count;\n        for (uint i = _start; i < _end; i++) {\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n                count++;\n            }\n        }\n        address[] memory res = new address[](count);\n        uint index = 0;\n        for (uint i = _start; i < _end; i++) {\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n                res[index] = tokenList[i];\n                index++;\n            }\n        }\n        return res;\n    }\n\n    function _updateToken(address _token, uint _status) internal returns (bool) {\n        require(_token != address(0), 'TokenRegistry: INVALID_TOKEN');\n        require(tokenStatus[_token] != _status, 'TokenRegistry: TOKEN_STATUS_NO_CHANGE');\n        if (tokenStatus[_token] == NONE) {\n            tokenCount++;\n            require(tokenCount <= uint(-1), 'TokenRegistry: OVERFLOW');\n            tokenList.push(_token);\n        }\n        tokenStatus[_token] = _status;\n        emit TokenStatusChanged(_token, _status, block.number);\n        return true;\n    }\n\n}"
    },
    "contracts/modules/Governable.sol": {
      "content": "pragma solidity >=0.5.16;\n\ncontract Governable {\n    address public governor;\n\n    event ChangeGovernor(address indexed _old, address indexed _new);\n\n    modifier onlyGovernor() {\n        require(msg.sender == governor, 'Governable: FORBIDDEN');\n        _;\n    }\n\n    // called after deployment\n    function initGovernorAddress(address _governor) internal {\n        require(_governor != address(0), 'Governable: INPUT_ADDRESS_IS_ZERO');\n        governor = _governor;\n    }\n\n    function changeGovernor(address _new) public onlyGovernor {\n        _changeGovernor(_new);\n    }\n\n    function _changeGovernor(address _new) internal {\n        require(_new != address(0), 'Governable: INVALID_ADDRESS');\n        require(_new != governor, 'Governable: NO_CHANGE');\n        address old = governor;\n        governor = _new;\n        emit ChangeGovernor(old, _new);\n    }\n\n}"
    },
    "contracts/TomiFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport './TomiPair.sol';\nimport './interfaces/ITomiConfig.sol';\n\ncontract TomiFactory {\n    uint256 public version = 1;\n    address public TGAS;\n    address public CONFIG;\n    address public owner;\n    mapping(address => mapping(address => address)) public getPair;\n    mapping(address => bool) public isPair;\n    address[] public allPairs;\n\n    mapping(address => address[]) public playerPairs;\n    mapping(address => mapping(address => bool)) isAddPlayerPair;\n\n    bytes32 public contractCodeHash;\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    constructor(address _TGAS, address _CONFIG) public {\n        TGAS = _TGAS;\n        CONFIG = _CONFIG;\n        owner = msg.sender;\n    }\n\n    function updateConfig(address _CONFIG) external {\n        require(msg.sender == owner, 'TOMI FACTORY: PERMISSION');\n        CONFIG = _CONFIG;\n        for(uint i = 0; i < allPairs.length; i ++) {\n            TomiPair(allPairs[i]).initialize(TomiPair(allPairs[i]).token0(), TomiPair(allPairs[i]).token1(), _CONFIG, TGAS);\n        }\n    }\n\n    function getPlayerPairCount(address player) external view returns (uint256) {\n        address[] storage existAddress = playerPairs[player];\n        if (existAddress.length == 0) return 0;\n        return existAddress.length;\n    }\n\n    function addPlayerPair(address _player, address _pair) external returns (bool) {\n        require(msg.sender == ITomiConfig(CONFIG).platform(), 'TOMI FACTORY: PERMISSION');\n        if (isAddPlayerPair[_player][_pair] == false) {\n            isAddPlayerPair[_player][_pair] = true;\n            playerPairs[_player].push(_pair);\n        }\n        return true;\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function createPair(address tokenA, address tokenB) external returns (address pair) {\n        require(msg.sender == ITomiConfig(CONFIG).platform(), 'TOMI FACTORY: PERMISSION');\n        require(tokenA != tokenB, 'TOMI FACTORY: IDENTICAL_ADDRESSES');\n        require(\n            ITomiConfig(CONFIG).checkToken(tokenA) && ITomiConfig(CONFIG).checkToken(tokenB),\n            'TOMI FACTORY: NOT LIST'\n        );\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'TOMI FACTORY: ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'TOMI FACTORY: PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(TomiPair).creationCode;\n        if (uint256(contractCodeHash) == 0) {\n            contractCodeHash = keccak256(bytecode);\n        }\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        isPair[pair] = true;\n        TomiPair(pair).initialize(token0, token1, CONFIG, TGAS);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n}"
    },
    "contracts/modules/ERC20Token.sol": {
      "content": "pragma solidity >=0.5.16;\n\nimport '../libraries/SafeMath.sol';\n\ncontract ERC20Token {\n    using SafeMath for uint;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    function _transfer(address from, address to, uint value) private {\n        require(balanceOf[from] >= value, 'ERC20Token: INSUFFICIENT_BALANCE');\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        if (to == address(0)) { // burn\n            totalSupply = totalSupply.sub(value);\n        }\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        require(allowance[from][msg.sender] >= value, 'ERC20Token: INSUFFICIENT_ALLOWANCE');\n        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n}\n"
    },
    "contracts/test/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\n\nimport '../modules/ERC20Token.sol';\n\ncontract ERC20 is ERC20Token {\n    constructor(uint _totalSupply, string memory _name, string memory _symbol) public {\n        name = _name;\n        symbol = _symbol;\n        totalSupply = _totalSupply;\n        balanceOf[msg.sender] = totalSupply;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}