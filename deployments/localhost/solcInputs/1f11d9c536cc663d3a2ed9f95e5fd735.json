{
  "language": "Solidity",
  "sources": {
    "contracts/ballots/TomiBallot.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\nimport '../interfaces/IERC20.sol';\r\n\r\n/**\r\n * @title TomiBallot\r\n * @dev Implements voting process along with vote delegation\r\n */\r\ncontract TomiBallot {\r\n    struct Voter {\r\n        uint256 weight; // weight is accumulated by delegation\r\n        bool voted; // if true, that person already voted\r\n        address delegate; // person delegated to\r\n        uint256 vote; // index of the voted proposal\r\n    }\r\n\r\n    mapping(address => Voter) public voters;\r\n    mapping(uint256 => uint256) public proposals;\r\n\r\n    address public governor;\r\n    address public proposer;\r\n    uint256 public value;\r\n    uint256 public endBlockNumber;\r\n    bool public ended;\r\n    string public subject;\r\n    string public content;\r\n\r\n    uint256 private constant NONE = 0;\r\n    uint256 private constant YES = 1;\r\n    uint256 private constant NO = 2;\r\n\r\n    uint256 public total;\r\n    uint256 public createTime;\r\n\r\n    modifier onlyGovernor() {\r\n        require(msg.sender == governor, 'TomiBallot: FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new ballot.\r\n     */\r\n    constructor(\r\n        address _proposer,\r\n        uint256 _value,\r\n        uint256 _endBlockNumber,\r\n        address _governor,\r\n        string memory _subject,\r\n        string memory _content\r\n    ) public {\r\n        proposer = _proposer;\r\n        value = _value;\r\n        endBlockNumber = _endBlockNumber;\r\n        governor = _governor;\r\n        subject = _subject;\r\n        content = _content;\r\n        proposals[YES] = 0;\r\n        proposals[NO] = 0;\r\n        createTime = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Give 'voter' the right to vote on this ballot.\r\n     * @param voter address of voter\r\n     */\r\n    function _giveRightToVote(address voter) private returns (Voter storage) {\r\n        require(block.number < endBlockNumber, 'Bollot is ended');\r\n        Voter storage sender = voters[voter];\r\n        require(!sender.voted, 'You already voted');\r\n        sender.weight += IERC20(governor).balanceOf(voter);\r\n        require(sender.weight != 0, 'Has no right to vote');\r\n        return sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Delegate your vote to the voter 'to'.\r\n     * @param to address to which vote is delegated\r\n     */\r\n    function delegate(address to) public {\r\n        Voter storage sender = _giveRightToVote(msg.sender);\r\n        require(to != msg.sender, 'Self-delegation is disallowed');\r\n\r\n        while (voters[to].delegate != address(0)) {\r\n            to = voters[to].delegate;\r\n\r\n            // We found a loop in the delegation, not allowed.\r\n            require(to != msg.sender, 'Found loop in delegation');\r\n        }\r\n        sender.voted = true;\r\n        sender.delegate = to;\r\n        Voter storage delegate_ = voters[to];\r\n        if (delegate_.voted) {\r\n            // If the delegate already voted,\r\n            // directly add to the number of votes\r\n            proposals[delegate_.vote] += sender.weight;\r\n            total += sender.weight;\r\n        } else {\r\n            // If the delegate did not vote yet,\r\n            // add to her weight.\r\n            delegate_.weight += sender.weight;\r\n            total += sender.weight;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.\r\n     * @param proposal index of proposal in the proposals array\r\n     */\r\n    function vote(uint256 proposal) public {\r\n        Voter storage sender = _giveRightToVote(msg.sender);\r\n        require(proposal == YES || proposal == NO, 'Only vote 1 or 2');\r\n        sender.voted = true;\r\n        sender.vote = proposal;\r\n        proposals[proposal] += sender.weight;\r\n        total += sender.weight;\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the winning proposal taking all previous votes into account.\r\n     * @return winningProposal_ index of winning proposal in the proposals array\r\n     */\r\n    function winningProposal() public view returns (uint256) {\r\n        if (proposals[YES] > proposals[NO]) {\r\n            return YES;\r\n        } else if (proposals[YES] < proposals[NO]) {\r\n            return NO;\r\n        } else {\r\n            return NONE;\r\n        }\r\n    }\r\n\r\n    function result() public view returns (bool) {\r\n        uint256 winner = winningProposal();\r\n        if (winner == YES) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function end() public onlyGovernor returns (bool) {\r\n        require(block.number >= endBlockNumber, 'ballot not yet ended');\r\n        require(!ended, 'end has already been called');\r\n        ended = true;\r\n        return result();\r\n    }\r\n\r\n    function weight(address user) external view returns (uint256) {\r\n        Voter memory voter = voters[user];\r\n        return voter.weight;\r\n    }\r\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}"
    },
    "contracts/ballots/TomiBallotFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\nimport \"./TomiBallot.sol\";\r\n\r\ncontract TomiBallotFactory {\r\n    event Created(address indexed proposer, address indexed ballotAddr, uint256 createTime);\r\n\r\n    constructor() public {}\r\n\r\n    function create(\r\n        address _proposer,\r\n        uint256 _value,\r\n        uint256 _endBlockNumber,\r\n        string calldata _subject,\r\n        string calldata _content\r\n    ) external returns (address) {\r\n        require(_value >= 0, 'TomiBallotFactory: INVALID_PARAMTERS');\r\n        address ballotAddr = address(\r\n            new TomiBallot(_proposer, _value, _endBlockNumber, msg.sender, _subject, _content)\r\n        );\r\n        emit Created(_proposer, ballotAddr, block.timestamp);\r\n        return ballotAddr;\r\n    }\r\n}\r\n"
    },
    "contracts/TomiTransferListener.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\nimport './modules/Ownable.sol';\r\nimport './interfaces/ITgas.sol';\r\nimport './interfaces/ITomiFactory.sol';\r\nimport './interfaces/IERC20.sol';\r\nimport './interfaces/ITomiPair.sol';\r\nimport './libraries/TomiSwapLibrary.sol';\r\nimport './libraries/SafeMath.sol';\r\n\r\ncontract TomiTransferListener is Ownable {\r\n    uint256 public version = 1;\r\n    address public TGAS;\r\n    address public PLATFORM;\r\n    address public WETH;\r\n    address public FACTORY;\r\n    address public admin;\r\n\r\n    mapping(address => uint) public pairWeights;\r\n\r\n    event Transfer(address indexed from, address indexed to, address indexed token, uint256 amount);\r\n    event WeightChanged(address indexed pair, uint weight);\r\n\r\n    function initialize(\r\n        address _TGAS,\r\n        address _FACTORY,\r\n        address _WETH,\r\n        address _PLATFORM,\r\n        address _admin\r\n    ) external onlyOwner {\r\n        require(\r\n            _TGAS != address(0) && _FACTORY != address(0) && _WETH != address(0) && _PLATFORM != address(0),\r\n            'TOMI TRANSFER LISTENER : INPUT ADDRESS IS ZERO'\r\n        );\r\n        TGAS = _TGAS;\r\n        FACTORY = _FACTORY;\r\n        WETH = _WETH;\r\n        PLATFORM = _PLATFORM;\r\n        admin = _admin;\r\n    }\r\n\r\n    function changeAdmin(address _admin) external onlyOwner {\r\n        admin = _admin;\r\n    }\r\n\r\n    function updateTGASImpl(address _newImpl) external onlyOwner {\r\n        ITgas(TGAS).upgradeImpl(_newImpl);\r\n    }\r\n\r\n    function updatePairPowers(address[] calldata _pairs, uint[] calldata _weights) external {\r\n        require(msg.sender == admin, 'TOMI TRANSFER LISTENER: ADMIN PERMISSION');\r\n        require(_pairs.length == _weights.length, \"TOMI TRANSFER LISTENER: INVALID PARAMS\");\r\n\r\n        for(uint i = 0;i < _weights.length;i++) {\r\n            pairWeights[_pairs[i]] = _weights[i];\r\n            _setProdutivity(_pairs[i]);\r\n            emit WeightChanged(_pairs[i], _weights[i]);\r\n        }\r\n    }\r\n\r\n\r\n    function _setProdutivity(address _pair) internal {\r\n        (uint256 lastProdutivity, ) = ITgas(TGAS).getProductivity(_pair);\r\n        address token0 = ITomiPair(_pair).token0();\r\n        address token1 = ITomiPair(_pair).token1();\r\n        (uint reserve0, uint reserve1, ) = ITomiPair(_pair).getReserves();\r\n        uint currentProdutivity = 0;\r\n        if(token0 == TGAS) {\r\n            currentProdutivity = reserve0 * pairWeights[_pair];\r\n        } else if(token1 == TGAS) {\r\n            currentProdutivity = reserve1 * pairWeights[_pair];\r\n        }\r\n\r\n        if(lastProdutivity != currentProdutivity) {\r\n            if(lastProdutivity > 0) {\r\n                ITgas(TGAS).decreaseProductivity(_pair, lastProdutivity);\r\n            } \r\n\r\n            if(currentProdutivity > 0) {\r\n                ITgas(TGAS).increaseProductivity(_pair, currentProdutivity);\r\n            }\r\n        }\r\n    }\r\n\r\n    function upgradeProdutivity(address fromPair, address toPair) external {\r\n        require(msg.sender == PLATFORM, 'TOMI TRANSFER LISTENER: PERMISSION');\r\n        (uint256 fromPairPower, ) = ITgas(TGAS).getProductivity(fromPair);\r\n        (uint256 toPairPower, ) = ITgas(TGAS).getProductivity(toPair);\r\n        if(fromPairPower > 0 && toPairPower == 0) {\r\n            ITgas(TGAS).decreaseProductivity(fromPair, fromPairPower);\r\n            ITgas(TGAS).increaseProductivity(toPair, fromPairPower);\r\n        }\r\n    }\r\n\r\n    function transferNotify(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        require(msg.sender == PLATFORM, 'TOMI TRANSFER LISTENER: PERMISSION');\r\n        if(ITomiFactory(FACTORY).isPair(from) && token == TGAS) {\r\n            _setProdutivity(from);\r\n        }\r\n\r\n        if(ITomiFactory(FACTORY).isPair(to) && token == TGAS) {\r\n            _setProdutivity(to);\r\n        }\r\n\r\n        emit Transfer(from, to, token, amount);\r\n        return true;\r\n    }\r\n}"
    },
    "contracts/modules/Ownable.sol": {
      "content": "pragma solidity >=0.5.16;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, 'Ownable: FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), 'Ownable: INVALID_ADDRESS');\r\n        emit OwnerChanged(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n}"
    },
    "contracts/interfaces/ITgas.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface ITgas {\r\n    function amountPerBlock() external view returns (uint);\r\n    function changeInterestRatePerBlock(uint value) external returns (bool);\r\n    function getProductivity(address user) external view returns (uint, uint);\r\n    function increaseProductivity(address user, uint value) external returns (bool);\r\n    function decreaseProductivity(address user, uint value) external returns (bool);\r\n    function take() external view returns (uint);\r\n    function takeWithBlock() external view returns (uint, uint);\r\n    function mint() external returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function upgradeImpl(address _newImpl) external;\r\n    function upgradeGovernance(address _newGovernor) external;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}"
    },
    "contracts/interfaces/ITomiFactory.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface ITomiFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function contractCodeHash() external view returns (bytes32);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function isPair(address pair) external view returns (bool);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function playerPairs(address player, uint index) external view returns (address pair);\r\n    function getPlayerPairCount(address player) external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function addPlayerPair(address player, address _pair) external returns (bool);\r\n}"
    },
    "contracts/interfaces/ITomiPair.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface ITomiPair {\r\n  \r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address from, address to, uint amount) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address tokenA, address tokenB, address platform, address tgas) external;\r\n    function swapFee(uint amount, address token, address to) external ;\r\n    function queryReward() external view returns (uint rewardAmount, uint blockNumber);\r\n    function mintReward() external returns (uint rewardAmount);\r\n    function getTGASReserve() external view returns (uint);\r\n}"
    },
    "contracts/libraries/TomiSwapLibrary.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\nimport '../interfaces/ITomiPair.sol';\r\nimport '../interfaces/ITomiFactory.sol';\r\nimport \"./SafeMath.sol\";\r\n\r\nlibrary TomiSwapLibrary {\r\n    using SafeMath for uint;\r\n\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'TomiSwapLibrary: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'TomiSwapLibrary: ZERO_ADDRESS');\r\n    }\r\n\r\n    function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n        bytes32 rawAddress = keccak256(\r\n        abi.encodePacked(\r\n            bytes1(0xff),\r\n            factory,\r\n            salt,\r\n            ITomiFactory(factory).contractCodeHash()\r\n            )\r\n        );\r\n        return address(bytes20(rawAddress << 96));\r\n    }\r\n\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = ITomiPair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n    \r\n    function quoteEnhance(address factory, address tokenA, address tokenB, uint amountA) internal view returns(uint amountB) {\r\n        (uint reserveA, uint reserveB) = getReserves(factory, tokenA, tokenB);\r\n        return quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA > 0, 'TomiSwapLibrary: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'TomiSwapLibrary: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'TomiSwapLibrary: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'TomiSwapLibrary: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = amountIn.mul(reserveOut);\r\n        uint denominator = reserveIn.add(amountIn);\r\n        amountOut = numerator / denominator;\r\n    }\r\n    \r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'TomiSwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'TomiSwapLibrary: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut);\r\n        uint denominator = reserveOut.sub(amountOut);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"
    },
    "contracts/TomiPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >= 0.5.1;\r\n\r\nimport './modules/Ownable.sol';\r\nimport './libraries/TransferHelper.sol';\r\nimport './interfaces/ITgas.sol';\r\nimport './interfaces/ITomiPair.sol';\r\nimport './interfaces/ITomiFactory.sol';\r\nimport './interfaces/ITomiGovernance.sol';\r\nimport './libraries/SafeMath.sol';\r\nimport './libraries/ConfigNames.sol';\r\nimport './interfaces/ITomiConfig.sol';\r\n\r\ninterface ITomiPlatform {\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts) ;\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n}\r\n\r\ncontract TomiPool is Ownable {\r\n\r\n    using SafeMath for uint;\r\n    address public TGAS;\r\n    address public FACTORY;\r\n    address public PLATFORM;\r\n    address public WETH;\r\n    address public CONFIG;\r\n    address public GOVERNANCE;\r\n    uint public totalReward;\r\n    \r\n    struct UserInfo {\r\n        uint rewardDebt; // Reward debt. \r\n        uint rewardEarn; // Reward earn and not minted\r\n    }\r\n    \r\n    event ClaimReward(address indexed user, address indexed pair, address indexed rewardToken, uint amountTGAS);\r\n    event AddReward(address indexed pair, uint amount);\r\n\r\n    mapping(address => mapping (address => UserInfo)) public users;\r\n    \r\n    mapping (address => uint) public pairAmountPerShare;\r\n    mapping (address => uint) public pairReward;\r\n    \r\n    function initialize(address _TGAS, address _WETH, address _FACTORY, address _PLATFORM, address _CONFIG, address _GOVERNANCE) external onlyOwner {\r\n        TGAS = _TGAS;\r\n        WETH = _WETH;\r\n        FACTORY = _FACTORY;\r\n        PLATFORM = _PLATFORM;\r\n        CONFIG = _CONFIG;\r\n        GOVERNANCE = _GOVERNANCE;\r\n    }\r\n    \r\n    function upgrade(address _newPool, address[] calldata _pairs) external onlyOwner {\r\n        ITgas(TGAS).approve(_newPool, totalReward);\r\n        for(uint i = 0;i < _pairs.length;i++) {\r\n            if(pairReward[_pairs[i]] > 0) {\r\n                TomiPool(_newPool).addReward(_pairs[i], pairReward[_pairs[i]]);\r\n                totalReward = totalReward.sub(pairReward[_pairs[i]]);\r\n                pairReward[_pairs[i]] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function addRewardFromPlatform(address _pair, uint _amount) external {\r\n        require(msg.sender == PLATFORM, \"TOMI POOL: FORBIDDEN\");\r\n        uint balanceOf = ITgas(TGAS).balanceOf(address(this));\r\n        require(balanceOf.sub(totalReward) >= _amount, 'TOMI POOL: ADD_REWARD_EXCEED');\r\n        \r\n        uint rewardAmount = ITomiConfig(CONFIG).getConfigValue(ConfigNames.FEE_LP_REWARD_PERCENT).mul(_amount).div(10000);\r\n        _addReward(_pair, rewardAmount);\r\n        \r\n        uint remainAmount = _amount.sub(rewardAmount);\r\n        uint governanceAmount = ITomiConfig(CONFIG).getConfigValue(ConfigNames.FEE_GOVERNANCE_REWARD_PERCENT).mul(remainAmount).div(10000);\r\n        if(governanceAmount > 0) {\r\n            TransferHelper.safeTransfer(TGAS, GOVERNANCE, governanceAmount);\r\n            ITomiGovernance(GOVERNANCE).addReward(governanceAmount);\r\n        }\r\n        if(remainAmount.sub(governanceAmount) > 0) {\r\n            TransferHelper.safeTransfer(TGAS, address(0), remainAmount.sub(governanceAmount));\r\n        }\r\n        emit AddReward(_pair, rewardAmount);\r\n    }\r\n    \r\n    function addReward(address _pair, uint _amount) external {\r\n        TransferHelper.safeTransferFrom(TGAS, msg.sender, address(this), _amount);\r\n        \r\n        require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\r\n        _addReward(_pair, _amount);\r\n        \r\n        emit AddReward(_pair, _amount);\r\n    }\r\n    \r\n    function preProductivityChanged(address _pair, address _user) external {\r\n        require(msg.sender == PLATFORM, \"TOMI POOL: FORBIDDEN\");\r\n        _auditUser(_pair, _user);\r\n    }\r\n    \r\n    function postProductivityChanged(address _pair, address _user) external {\r\n        require(msg.sender == PLATFORM, \"TOMI POOL: FORBIDDEN\");\r\n        require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\r\n        \r\n        _updateDebt(_pair, _user);\r\n    }\r\n    \r\n    function _addReward(address _pair, uint _amount) internal {\r\n        pairReward[_pair] = pairReward[_pair].add(_amount);\r\n        uint totalProdutivity = ITomiPair(_pair).totalSupply();\r\n        if(totalProdutivity > 0) {\r\n            pairAmountPerShare[_pair] = pairAmountPerShare[_pair].add(_amount.mul(1e12).div(totalProdutivity));\r\n            totalReward = totalReward.add(_amount);\r\n        }\r\n    }\r\n    \r\n    function _auditUser(address _pair, address _user) internal {\r\n        require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\r\n    \r\n        uint balance = ITomiPair(_pair).balanceOf(_user);\r\n        uint accAmountPerShare = pairAmountPerShare[_pair];\r\n        UserInfo storage userInfo = users[_user][_pair];\r\n        uint pending = balance.mul(accAmountPerShare).div(1e12).sub(userInfo.rewardDebt);\r\n        userInfo.rewardEarn = userInfo.rewardEarn.add(pending);\r\n        userInfo.rewardDebt = balance.mul(accAmountPerShare).div(1e12);\r\n    }\r\n    \r\n    function _updateDebt(address _pair, address _user) internal {\r\n        uint balance = ITomiPair(_pair).balanceOf(_user);\r\n        uint accAmountPerShare = pairAmountPerShare[_pair];\r\n        users[_user][_pair].rewardDebt = balance.mul(accAmountPerShare).div(1e12);\r\n    }\r\n    \r\n    function claimReward(address _pair, address _rewardToken) external {\r\n        _auditUser(_pair, msg.sender);\r\n        UserInfo storage userInfo = users[msg.sender][_pair];\r\n        \r\n        uint amount = userInfo.rewardEarn;\r\n        pairReward[_pair] = pairReward[_pair].sub(amount);\r\n        totalReward = totalReward.sub(amount);\r\n        require(amount > 0, \"NOTHING TO MINT\");\r\n        \r\n        if(_rewardToken == TGAS) {\r\n            TransferHelper.safeTransfer(TGAS, msg.sender, amount);\r\n        } else if(_rewardToken == WETH) {\r\n            require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\r\n            ITgas(TGAS).approve(PLATFORM, amount);\r\n            address[] memory path = new address[](2);\r\n            path[0] = TGAS;\r\n            path[1] = WETH; \r\n            ITomiPlatform(PLATFORM).swapExactTokensForETH(amount, 0, path, msg.sender, block.timestamp + 1);\r\n        } else {\r\n            require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\r\n            ITgas(TGAS).approve(PLATFORM, amount);\r\n            address[] memory path = new address[](2);\r\n            path[0] = TGAS;\r\n            path[1] = _rewardToken;\r\n            ITomiPlatform(PLATFORM).swapExactTokensForTokens(amount, 0, path, msg.sender, block.timestamp + 1);\r\n        }\r\n        \r\n        userInfo.rewardEarn = 0;\r\n        emit ClaimReward(msg.sender, _pair, _rewardToken, amount);\r\n    }\r\n    \r\n    function queryReward(address _pair, address _user) external view returns(uint) {\r\n        require(ITomiFactory(FACTORY).isPair(_pair), \"TOMI POOL: INVALID PAIR\");\r\n        \r\n        UserInfo memory userInfo = users[msg.sender][_pair];\r\n        uint balance = ITomiPair(_pair).balanceOf(_user);\r\n        return balance.mul(pairAmountPerShare[_pair]).div(1e12).add(userInfo.rewardEarn).sub(userInfo.rewardDebt);\r\n    }\r\n}"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.6.0;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}"
    },
    "contracts/interfaces/ITomiGovernance.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface ITomiGovernance {\r\n    function addPair(address _tokenA, address _tokenB) external returns (bool);\r\n    function addReward(uint _value) external returns (bool);\r\n}\r\n"
    },
    "contracts/libraries/ConfigNames.sol": {
      "content": "pragma solidity >=0.5.16;\r\n\r\nlibrary ConfigNames {\r\n    bytes32 public constant PRODUCE_TGAS_RATE = bytes32('PRODUCE_TGAS_RATE');\r\n    bytes32 public constant SWAP_FEE_PERCENT = bytes32('SWAP_FEE_PERCENT');\r\n    bytes32 public constant LIST_TGAS_AMOUNT = bytes32('LIST_TGAS_AMOUNT');\r\n    bytes32 public constant UNSTAKE_DURATION = bytes32('UNSTAKE_DURATION');\r\n    bytes32 public constant REMOVE_LIQUIDITY_DURATION = bytes32('REMOVE_LIQUIDITY_DURATION');\r\n    bytes32 public constant TOKEN_TO_TGAS_PAIR_MIN_PERCENT = bytes32('TOKEN_TO_TGAS_PAIR_MIN_PERCENT');\r\n    bytes32 public constant LIST_TOKEN_FAILURE_BURN_PRECENT = bytes32('LIST_TOKEN_FAILURE_BURN_PRECENT');\r\n    bytes32 public constant LIST_TOKEN_SUCCESS_BURN_PRECENT = bytes32('LIST_TOKEN_SUCCESS_BURN_PRECENT');\r\n    bytes32 public constant PROPOSAL_TGAS_AMOUNT = bytes32('PROPOSAL_TGAS_AMOUNT');\r\n    bytes32 public constant VOTE_DURATION = bytes32('VOTE_DURATION');\r\n    bytes32 public constant VOTE_REWARD_PERCENT = bytes32('VOTE_REWARD_PERCENT');\r\n    bytes32 public constant TOKEN_PENGDING_SWITCH = bytes32('TOKEN_PENGDING_SWITCH');\r\n    bytes32 public constant TOKEN_PENGDING_TIME = bytes32('TOKEN_PENGDING_TIME');\r\n    bytes32 public constant LIST_TOKEN_SWITCH = bytes32('LIST_TOKEN_SWITCH');\r\n    bytes32 public constant DEV_PRECENT = bytes32('DEV_PRECENT');\r\n    bytes32 public constant FEE_GOVERNANCE_REWARD_PERCENT = bytes32('FEE_GOVERNANCE_REWARD_PERCENT');\r\n    bytes32 public constant FEE_LP_REWARD_PERCENT = bytes32('FEE_LP_REWARD_PERCENT');\r\n    bytes32 public constant FEE_FUNDME_REWARD_PERCENT = bytes32('FEE_FUNDME_REWARD_PERCENT');\r\n    bytes32 public constant FEE_LOTTERY_REWARD_PERCENT = bytes32('FEE_LOTTERY_REWARD_PERCENT');\r\n}"
    },
    "contracts/interfaces/ITomiConfig.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface ITomiConfig {\r\n    function governor() external view returns (address);\r\n    function dev() external view returns (address);\r\n    function PERCENT_DENOMINATOR() external view returns (uint);\r\n    function getConfig(bytes32 _name) external view returns (uint minValue, uint maxValue, uint maxSpan, uint value, uint enable);\r\n    function getConfigValue(bytes32 _name) external view returns (uint);\r\n    function changeConfigValue(bytes32 _name, uint _value) external returns (bool);\r\n    function checkToken(address _token) external view returns(bool);\r\n    function checkPair(address tokenA, address tokenB) external view returns (bool);\r\n    function listToken(address _token) external returns (bool);\r\n    function getDefaultListTokens() external returns (address[] memory);\r\n    function platform() external view returns  (address);\r\n    function addToken(address _token) external returns (bool);\r\n}"
    },
    "contracts/TomiPlatform.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\nimport './libraries/ConfigNames.sol';\r\nimport './libraries/SafeMath.sol';\r\nimport './libraries/TransferHelper.sol';\r\nimport './libraries/TomiSwapLibrary.sol';\r\nimport './interfaces/IWETH.sol';\r\nimport './interfaces/ITomiGovernance.sol';\r\nimport './interfaces/ITomiConfig.sol';\r\nimport './interfaces/IERC20.sol';\r\nimport './interfaces/ITomiFactory.sol';\r\nimport './interfaces/ITomiPair.sol';\r\nimport './interfaces/ITomiPool.sol';\r\nimport './modules/Ownable.sol';\r\nimport './modules/ReentrancyGuard.sol';\r\nimport './interfaces/ITomiTransferListener.sol';\r\nimport './interfaces/ITokenRegistry.sol';\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract TomiPlatform is Ownable {\r\n    uint256 public version = 1;\r\n    address public TGAS;\r\n    address public CONFIG;\r\n    address public FACTORY;\r\n    address public WETH;\r\n    address public GOVERNANCE;\r\n    address public TRANSFER_LISTENER;\r\n    address public POOL;\r\n    uint256 public constant PERCENT_DENOMINATOR = 10000;\r\n\r\n    bool public isPause;\r\n\r\n    event AddLiquidity(\r\n        address indexed player,\r\n        address indexed tokenA,\r\n        address indexed tokenB,\r\n        uint256 amountA,\r\n        uint256 amountB\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed player,\r\n        address indexed tokenA,\r\n        address indexed tokenB,\r\n        uint256 amountA,\r\n        uint256 amountB\r\n    );\r\n    event SwapToken(\r\n        address indexed receiver,\r\n        address indexed fromToken,\r\n        address indexed toToken,\r\n        uint256 inAmount,\r\n        uint256 outAmount\r\n    );\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH);\r\n    }\r\n\r\n    modifier ensure(uint256 deadline) {\r\n        require(deadline >= block.timestamp, 'TOMI PLATFORM : EXPIRED');\r\n        _;\r\n    }\r\n\r\n    modifier noneTokenCall() {\r\n        require(ITokenRegistry(CONFIG).tokenStatus(msg.sender) == 0, 'TOMI PLATFORM : ILLEGAL CALL');\r\n        _;\r\n    }\r\n\r\n    function initialize(\r\n        address _TGAS,\r\n        address _CONFIG,\r\n        address _FACTORY,\r\n        address _WETH,\r\n        address _GOVERNANCE,\r\n        address _TRANSFER_LISTENER,\r\n        address _POOL\r\n    ) external onlyOwner {\r\n        TGAS = _TGAS;\r\n        CONFIG = _CONFIG;\r\n        FACTORY = _FACTORY;\r\n        WETH = _WETH;\r\n        GOVERNANCE = _GOVERNANCE;\r\n        TRANSFER_LISTENER = _TRANSFER_LISTENER;\r\n        POOL = _POOL;\r\n    }\r\n\r\n    function pause() external onlyOwner {\r\n        isPause = true;\r\n    }\r\n\r\n    function resume() external onlyOwner {\r\n        isPause = false;\r\n    }\r\n\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin\r\n    ) internal returns (uint256 amountA, uint256 amountB) {\r\n        if (ITomiFactory(FACTORY).getPair(tokenA, tokenB) == address(0)) {\r\n            ITomiConfig(CONFIG).addToken(tokenA);\r\n            ITomiConfig(CONFIG).addToken(tokenB);\r\n            ITomiFactory(FACTORY).createPair(tokenA, tokenB);\r\n        }\r\n        require(\r\n            ITomiConfig(CONFIG).checkPair(tokenA, tokenB),\r\n            'TOMI PLATFORM : ADD LIQUIDITY PAIR CONFIG CHECK FAIL'\r\n        );\r\n        (uint256 reserveA, uint256 reserveB) = TomiSwapLibrary.getReserves(FACTORY, tokenA, tokenB);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint256 amountBOptimal = TomiSwapLibrary.quote(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= amountBMin, 'TOMI PLATFORM : INSUFFICIENT_B_AMOUNT');\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint256 amountAOptimal = TomiSwapLibrary.quote(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, 'TOMI PLATFORM : INSUFFICIENT_A_AMOUNT');\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n        ITomiFactory(FACTORY).addPlayerPair(msg.sender, ITomiFactory(FACTORY).getPair(tokenA, tokenB));\r\n    }\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        ensure(deadline)\r\n        returns (\r\n            uint256 _amountA,\r\n            uint256 _amountB,\r\n            uint256 _liquidity\r\n        )\r\n{\r\n        require(!isPause, \"TOMI PAUSED\");\r\n        (_amountA, _amountB) = _addLiquidity(tokenA, tokenB, amountA, amountB, amountAMin, amountBMin);\r\n        address pair = TomiSwapLibrary.pairFor(FACTORY, tokenA, tokenB);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, _amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, _amountB);\r\n\r\n        // notify pool\r\n        ITomiPool(POOL).preProductivityChanged(pair, msg.sender);\r\n        _liquidity = ITomiPair(pair).mint(msg.sender);\r\n        ITomiPool(POOL).postProductivityChanged(pair, msg.sender);\r\n\r\n        _transferNotify(msg.sender, pair, tokenA, _amountA);\r\n        _transferNotify(msg.sender, pair, tokenB, _amountB);\r\n        emit AddLiquidity(msg.sender, tokenA, tokenB, _amountA, _amountB);\r\n    }\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        ensure(deadline)\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        require(!isPause, \"TOMI PAUSED\");\r\n        (amountToken, amountETH) = _addLiquidity(\r\n            token,\r\n            WETH,\r\n            amountTokenDesired,\r\n            msg.value,\r\n            amountTokenMin,\r\n            amountETHMin\r\n        );\r\n        address pair = TomiSwapLibrary.pairFor(FACTORY, token, WETH);\r\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        IWETH(WETH).deposit{value: amountETH}();\r\n        assert(IWETH(WETH).transfer(pair, amountETH));\r\n\r\n        // notify pool\r\n        ITomiPool(POOL).preProductivityChanged(pair, msg.sender);\r\n        liquidity = ITomiPair(pair).mint(msg.sender);\r\n        ITomiPool(POOL).postProductivityChanged(pair, msg.sender);\r\n\r\n        _transferNotify(msg.sender, pair, WETH, amountETH);\r\n        _transferNotify(msg.sender, pair, token, amountToken);\r\n        emit AddLiquidity(msg.sender, token, WETH, amountToken, amountETH);\r\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) public ensure(deadline) returns (uint256 amountA, uint256 amountB) {\r\n        require(!isPause, \"TOMI PAUSED\");\r\n        address pair = TomiSwapLibrary.pairFor(FACTORY, tokenA, tokenB);\r\n        uint256 _liquidity = liquidity;\r\n        address _tokenA = tokenA;\r\n        address _tokenB = tokenB;\r\n\r\n        // notify pool\r\n        ITomiPool(POOL).preProductivityChanged(pair, msg.sender);\r\n        (uint256 amount0, uint256 amount1) = ITomiPair(pair).burn(msg.sender, to, _liquidity);\r\n        ITomiPool(POOL).postProductivityChanged(pair, msg.sender);\r\n\r\n        (address token0, ) = TomiSwapLibrary.sortTokens(_tokenA, _tokenB);\r\n        (amountA, amountB) = _tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        _transferNotify(pair, to, _tokenA, amountA);\r\n        _transferNotify(pair, to, _tokenB, amountB);\r\n        require(amountA >= amountAMin, 'TOMI PLATFORM : INSUFFICIENT_A_AMOUNT');\r\n        require(amountB >= amountBMin, 'TOMI PLATFORM : INSUFFICIENT_B_AMOUNT');\r\n        emit RemoveLiquidity(msg.sender, _tokenA, _tokenB, amountA, amountB);\r\n    }\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) public ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {\r\n        require(!isPause, \"TOMI PAUSED\");\r\n        (amountToken, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, amountToken);\r\n        IWETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n        _transferNotify(address(this), to, token, amountToken);\r\n        _transferNotify(address(this), to, WETH, amountETH);\r\n    }\r\n\r\n    function _getAmountsOut(\r\n        uint256 amount,\r\n        address[] memory path,\r\n        uint256 percent\r\n    ) internal view returns (uint256[] memory amountOuts) {\r\n        amountOuts = new uint256[](path.length);\r\n        amountOuts[0] = amount;\r\n        for (uint256 i = 0; i < path.length - 1; i++) {\r\n            address inPath = path[i];\r\n            address outPath = path[i + 1];\r\n            (uint256 reserveA, uint256 reserveB) = TomiSwapLibrary.getReserves(FACTORY, inPath, outPath);\r\n            uint256 outAmount = SafeMath.mul(amountOuts[i], SafeMath.sub(PERCENT_DENOMINATOR, percent));\r\n            amountOuts[i + 1] = TomiSwapLibrary.getAmountOut(outAmount / PERCENT_DENOMINATOR, reserveA, reserveB);\r\n        }\r\n    }\r\n\r\n    function _getAmountsIn(\r\n        uint256 amount,\r\n        address[] memory path,\r\n        uint256 percent\r\n    ) internal view returns (uint256[] memory amountIn) {\r\n        amountIn = new uint256[](path.length);\r\n        amountIn[path.length - 1] = amount;\r\n        for (uint256 i = path.length - 1; i > 0; i--) {\r\n            address inPath = path[i - 1];\r\n            address outPath = path[i];\r\n            (uint256 reserveA, uint256 reserveB) = TomiSwapLibrary.getReserves(FACTORY, inPath, outPath);\r\n            uint256 inAmount = TomiSwapLibrary.getAmountIn(amountIn[i], reserveA, reserveB);\r\n            amountIn[i - 1] = SafeMath.add(\r\n                SafeMath.mul(inAmount, PERCENT_DENOMINATOR) / SafeMath.sub(PERCENT_DENOMINATOR, percent),\r\n                1\r\n            );\r\n        }\r\n        amountIn = _getAmountsOut(amountIn[0], path, percent);\r\n    }\r\n\r\n    function swapPrecondition(address token) public view returns (bool) {\r\n        if (token == TGAS || token == WETH) return true;\r\n        uint256 percent = ITomiConfig(CONFIG).getConfigValue(ConfigNames.TOKEN_TO_TGAS_PAIR_MIN_PERCENT);\r\n        if (!existPair(WETH, TGAS)) return false;\r\n        if (!existPair(TGAS, token)) return false;\r\n        if (!(ITomiConfig(CONFIG).checkPair(TGAS, token) && ITomiConfig(CONFIG).checkPair(WETH, token))) return false;\r\n        if (!existPair(WETH, token)) return true;\r\n        if (percent == 0) return true;\r\n        (uint256 reserveTGAS, ) = TomiSwapLibrary.getReserves(FACTORY, TGAS, token);\r\n        (uint256 reserveWETH, ) = TomiSwapLibrary.getReserves(FACTORY, WETH, token);\r\n        (uint256 reserveWETH2, uint256 reserveTGAS2) = TomiSwapLibrary.getReserves(FACTORY, WETH, TGAS);\r\n        uint256 tgasValue = SafeMath.mul(reserveTGAS, reserveWETH2) / reserveTGAS2;\r\n        uint256 limitValue = SafeMath.mul(SafeMath.add(tgasValue, reserveWETH), percent) / PERCENT_DENOMINATOR;\r\n        return tgasValue >= limitValue;\r\n    }\r\n         \r\n    function checkPath(address _path, address[] memory _paths) public pure returns (bool) {\r\n        uint count;\r\n        for(uint i; i<_paths.length; i++) {\r\n            if(_paths[i] == _path) {\r\n                count++;\r\n            }\r\n        }\r\n        if(count == 1) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _swap(\r\n        uint256[] memory amounts,\r\n        address[] memory path,\r\n        address _to\r\n    ) internal {\r\n        require(!isPause, \"TOMI PAUSED\");\r\n        require(swapPrecondition(path[path.length - 1]), 'TOMI PLATFORM : CHECK TGAS/TOKEN TO VALUE FAIL');\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            require(checkPath(path[i], path) && checkPath(path[i + 1], path), 'DEMAX PLATFORM : INVALID PATH');\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            require(swapPrecondition(input), 'TOMI PLATFORM : CHECK TGAS/TOKEN VALUE FROM FAIL');\r\n            require(ITomiConfig(CONFIG).checkPair(input, output), 'TOMI PLATFORM : SWAP PAIR CONFIG CHECK FAIL');\r\n            (address token0, address token1) = TomiSwapLibrary.sortTokens(input, output);\r\n            uint256 amountOut = amounts[i + 1];\r\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\r\n                ? (uint256(0), amountOut)\r\n                : (amountOut, uint256(0));\r\n            address to = i < path.length - 2 ? TomiSwapLibrary.pairFor(FACTORY, output, path[i + 2]) : _to;\r\n\r\n            // add k check\r\n            address pair = TomiSwapLibrary.pairFor(FACTORY, input, output);\r\n            (uint reserve0, uint resereve1, ) = ITomiPair(pair).getReserves();\r\n            uint kBefore = SafeMath.mul(reserve0, resereve1);\r\n\r\n            ITomiPair(pair).swap(amount0Out, amount1Out, to, new bytes(0));\r\n\r\n            (reserve0, resereve1, ) = ITomiPair(pair).getReserves();\r\n            uint kAfter = SafeMath.mul(reserve0, resereve1);\r\n            require(kBefore <= kAfter, \"Burger K\");\r\n\r\n            if (amount0Out > 0)\r\n                _transferNotify(TomiSwapLibrary.pairFor(FACTORY, input, output), to, token0, amount0Out);\r\n            if (amount1Out > 0)\r\n                _transferNotify(TomiSwapLibrary.pairFor(FACTORY, input, output), to, token1, amount1Out);\r\n        }\r\n        emit SwapToken(_to, path[0], path[path.length - 1], amounts[0], amounts[path.length - 1]);\r\n    }\r\n\r\n    function _swapFee(\r\n        uint256[] memory amounts,\r\n        address[] memory path,\r\n        uint256 percent\r\n    ) internal {\r\n        for (uint256 i = 0; i < path.length - 1; i++) {\r\n            uint256 fee = SafeMath.mul(amounts[i], percent) / PERCENT_DENOMINATOR;\r\n            address input = path[i];\r\n            address output = path[i + 1];\r\n            address currentPair = TomiSwapLibrary.pairFor(FACTORY, input, output);\r\n            if (input == TGAS) {\r\n                ITomiPair(currentPair).swapFee(fee, TGAS, POOL);\r\n                _transferNotify(currentPair, POOL, TGAS, fee);\r\n            } else {\r\n                ITomiPair(currentPair).swapFee(fee, input, TomiSwapLibrary.pairFor(FACTORY, input, TGAS));\r\n                (uint256 reserveIn, uint256 reserveTGAS) = TomiSwapLibrary.getReserves(FACTORY, input, TGAS);\r\n                uint256 feeOut = TomiSwapLibrary.getAmountOut(fee, reserveIn, reserveTGAS);\r\n                ITomiPair(TomiSwapLibrary.pairFor(FACTORY, input, TGAS)).swapFee(feeOut, TGAS, POOL);\r\n                _transferNotify(currentPair, TomiSwapLibrary.pairFor(FACTORY, input, TGAS), input, fee);\r\n                _transferNotify(TomiSwapLibrary.pairFor(FACTORY, input, TGAS), POOL, TGAS, feeOut);\r\n                fee = feeOut;\r\n            }\r\n            if (fee > 0) ITomiPool(POOL).addRewardFromPlatform(currentPair, fee);\r\n        }\r\n    }\r\n\r\n    function _getSwapFeePercent() internal view returns (uint256) {\r\n        return ITomiConfig(CONFIG).getConfigValue(ConfigNames.SWAP_FEE_PERCENT);\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\r\n\r\n        uint256 percent = _getSwapFeePercent();\r\n        amounts = _getAmountsOut(amountIn, path, percent);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'TOMI PLATFORM : INSUFFICIENT_OUTPUT_AMOUNT');\r\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\r\n        _innerTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            pair,\r\n            SafeMath.mul(amountIn, SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\r\n        );\r\n        _swap(amounts, path, to);\r\n        _innerTransferFrom(path[0], msg.sender, pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\r\n        _swapFee(amounts, path, percent);\r\n    }\r\n\r\n    function _innerTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        TransferHelper.safeTransferFrom(token, from, to, amount);\r\n        _transferNotify(from, to, token, amount);\r\n    }\r\n\r\n    function _innerTransferWETH(address to, uint256 amount) internal {\r\n        assert(IWETH(WETH).transfer(to, amount));\r\n        _transferNotify(address(this), to, WETH, amount);\r\n    }\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable ensure(deadline) returns (uint256[] memory amounts) {\r\n        require(path[0] == WETH, 'TOMI PLATFORM : INVALID_PATH');\r\n        uint256 percent = _getSwapFeePercent();\r\n        amounts = _getAmountsOut(msg.value, path, percent);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'TOMI PLATFORM : INSUFFICIENT_OUTPUT_AMOUNT');\r\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\r\n        IWETH(WETH).deposit{\r\n            value: SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\r\n        }();\r\n        _innerTransferWETH(\r\n            pair,\r\n            SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\r\n        );\r\n        _swap(amounts, path, to);\r\n\r\n        IWETH(WETH).deposit{value: SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR}();\r\n        _innerTransferWETH(pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\r\n        _swapFee(amounts, path, percent);\r\n    }\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\r\n        require(path[path.length - 1] == WETH, 'TOMI PLATFORM : INVALID_PATH');\r\n        uint256 percent = _getSwapFeePercent();\r\n        amounts = _getAmountsOut(amountIn, path, percent);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'TOMI PLATFORM : INSUFFICIENT_OUTPUT_AMOUNT');\r\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\r\n        _innerTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            pair,\r\n            SafeMath.mul(amountIn, SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\r\n        );\r\n        _swap(amounts, path, address(this));\r\n\r\n        _innerTransferFrom(path[0], msg.sender, pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\r\n        _swapFee(amounts, path, percent);\r\n\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\r\n        uint256 percent = _getSwapFeePercent();\r\n        amounts = _getAmountsIn(amountOut, path, percent);\r\n        require(amounts[0] <= amountInMax, 'TOMI PLATFORM : EXCESSIVE_INPUT_AMOUNT');\r\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\r\n\r\n        _innerTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            pair,\r\n            SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\r\n        );\r\n        _swap(amounts, path, to);\r\n        _innerTransferFrom(path[0], msg.sender, pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\r\n        _swapFee(amounts, path, percent);\r\n    }\r\n\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\r\n        require(path[path.length - 1] == WETH, 'TOMI PLATFORM : INVALID_PATH');\r\n        uint256 percent = _getSwapFeePercent();\r\n        amounts = _getAmountsIn(amountOut, path, percent);\r\n        require(amounts[0] <= amountInMax, 'TOMI PLATFORM : EXCESSIVE_INPUT_AMOUNT');\r\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\r\n        _innerTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            pair,\r\n            SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n\r\n        _innerTransferFrom(path[0], msg.sender, pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\r\n        _swapFee(amounts, path, percent);\r\n    }\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable ensure(deadline) returns (uint256[] memory amounts) {\r\n        require(path[0] == WETH, 'TOMI PLATFORM : INVALID_PATH');\r\n        uint256 percent = _getSwapFeePercent();\r\n        amounts = _getAmountsIn(amountOut, path, percent);\r\n        require(amounts[0] <= msg.value, 'TOMI PLATFORM : EXCESSIVE_INPUT_AMOUNT');\r\n\r\n        IWETH(WETH).deposit{\r\n            value: SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\r\n        }();\r\n        address pair = TomiSwapLibrary.pairFor(FACTORY, path[0], path[1]);\r\n        _innerTransferWETH(\r\n            pair,\r\n            SafeMath.mul(amounts[0], SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR\r\n        );\r\n        _swap(amounts, path, to);\r\n\r\n        IWETH(WETH).deposit{value: SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR}();\r\n        _innerTransferWETH(pair, SafeMath.mul(amounts[0], percent) / PERCENT_DENOMINATOR);\r\n        _swapFee(amounts, path, percent);\r\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n    }\r\n\r\n    function _transferNotify(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint256 amount\r\n    ) internal {\r\n        ITomiTransferListener(TRANSFER_LISTENER).transferNotify(from, to, token, amount);\r\n    }\r\n\r\n    function existPair(address tokenA, address tokenB) public view returns (bool) {\r\n        return ITomiFactory(FACTORY).getPair(tokenA, tokenB) != address(0);\r\n    }\r\n\r\n    function getReserves(address tokenA, address tokenB) public view returns (uint256, uint256) {\r\n        return TomiSwapLibrary.getReserves(FACTORY, tokenA, tokenB);\r\n    }\r\n\r\n    function pairFor(address tokenA, address tokenB) public view returns (address) {\r\n        return TomiSwapLibrary.pairFor(FACTORY, tokenA, tokenB);\r\n    }\r\n\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) public view returns (uint256 amountOut) {\r\n        uint256 percent = _getSwapFeePercent();\r\n        uint256 amount = SafeMath.mul(amountIn, SafeMath.sub(PERCENT_DENOMINATOR, percent)) / PERCENT_DENOMINATOR;\r\n        return TomiSwapLibrary.getAmountOut(amount, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) public view returns (uint256 amountIn) {\r\n        uint256 percent = _getSwapFeePercent();\r\n        uint256 amount = TomiSwapLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\r\n        return SafeMath.mul(amount, PERCENT_DENOMINATOR) / SafeMath.sub(PERCENT_DENOMINATOR, percent);\r\n    }\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] memory path) public view returns (uint256[] memory amounts) {\r\n        uint256 percent = _getSwapFeePercent();\r\n        return _getAmountsOut(amountIn, path, percent);\r\n    }\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] memory path) public view returns (uint256[] memory amounts) {\r\n        uint256 percent = _getSwapFeePercent();\r\n        return _getAmountsIn(amountOut, path, percent);\r\n    }\r\n\r\n    function migrateLiquidity(address pair, address tokenA, address tokenB, address[] calldata users) external onlyOwner {\r\n        if (ITomiFactory(FACTORY).getPair(tokenA, tokenB) == address(0)) {\r\n            ITomiFactory(FACTORY).createPair(tokenA, tokenB);\r\n        }\r\n        address newPair = ITomiFactory(FACTORY).getPair(tokenA, tokenB);\r\n        for(uint i = 0; i < users.length; i++) {\r\n            uint liquidity = ITomiPair(pair).balanceOf(users[i]);\r\n            if(liquidity > 0) {\r\n                ITomiPair(pair).burn(users[i], newPair, liquidity);\r\n                ITomiPair(newPair).mint(users[i]);\r\n                ITomiFactory(FACTORY).addPlayerPair(users[i], newPair);\r\n            }\r\n        }\r\n\r\n        ITomiTransferListener(TRANSFER_LISTENER).upgradeProdutivity(pair, newPair);    \r\n\r\n    }\r\n}"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n"
    },
    "contracts/interfaces/ITomiPool.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface ITomiPool {\r\n    function addRewardFromPlatform(address _pair, uint _amount) external;\r\n    function preProductivityChanged(address _pair, address _user) external;\r\n    function postProductivityChanged(address _pair, address _user) external;\r\n}"
    },
    "contracts/modules/ReentrancyGuard.sol": {
      "content": "/**\r\n *Submitted for verification at BscScan.com on 2021-06-30\r\n*/\r\n\r\npragma solidity >=0.6.6;\r\n\r\ninterface IDemaxTransferListener {\r\n    function transferNotify(address from, address to, address token, uint amount)  external returns (bool);\r\n    function upgradeProdutivity(address fromPair, address toPair) external;\r\n}\r\n// Dependency file: contracts/modules/ReentrancyGuard.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ITomiTransferListener.sol": {
      "content": "pragma solidity >=0.6.6;\r\n\r\ninterface ITomiTransferListener {\r\n    function transferNotify(address from, address to, address token, uint amount)  external returns (bool);\r\n    function upgradeProdutivity(address fromPair, address toPair) external;\r\n}"
    },
    "contracts/interfaces/ITokenRegistry.sol": {
      "content": "pragma solidity >=0.5.16;\r\n\r\ninterface ITokenRegistry {\r\n    function tokenStatus(address _token) external view returns(uint);\r\n    function pairStatus(address tokenA, address tokenB) external view returns (uint);\r\n    function NONE() external view returns(uint);\r\n    function REGISTERED() external view returns(uint);\r\n    function PENDING() external view returns(uint);\r\n    function OPENED() external view returns(uint);\r\n    function CLOSED() external view returns(uint);\r\n    function registryToken(address _token) external returns (bool);\r\n    function publishToken(address _token) external returns (bool);\r\n    function updateToken(address _token, uint _status) external returns (bool);\r\n    function updatePair(address tokenA, address tokenB, uint _status) external returns (bool);\r\n    function tokenCount() external view returns(uint);\r\n    function validTokens() external view returns(address[] memory);\r\n    function iterateValidTokens(uint32 _start, uint32 _end) external view returns (address[] memory);\r\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/TomiGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\nimport './interfaces/ITomiConfig.sol';\r\nimport './interfaces/ITomiBallotFactory.sol';\r\nimport './interfaces/ITomiBallot.sol';\r\nimport './interfaces/ITgas.sol';\r\nimport './interfaces/ITokenRegistry.sol';\r\nimport './libraries/ConfigNames.sol';\r\nimport './libraries/TransferHelper.sol';\r\nimport './modules/TgasStaking.sol';\r\nimport './modules/Ownable.sol';\r\n\r\ncontract TomiGovernance is TgasStaking, Ownable {\r\n    uint public version = 1;\r\n    address public configAddr;\r\n    address public ballotFactoryAddr;\r\n    address public rewardAddr;\r\n\r\n    uint public T_CONFIG = 1;\r\n    uint public T_LIST_TOKEN = 2;\r\n    uint public T_TOKEN = 3;\r\n    mapping(address => uint) public ballotTypes;\r\n    mapping(address => bytes32) public configBallots;\r\n    mapping(address => address) public tokenBallots;\r\n    mapping(address => uint) public rewardOf;\r\n    mapping(address => uint) public ballotOf;\r\n    mapping(address => mapping(address => uint)) public applyTokenOf;\r\n    mapping(address => mapping(address => bool)) public collectUsers;\r\n    mapping(address => address) public tokenUsers;\r\n\r\n    address[] public ballots;\r\n\r\n    event ConfigAudited(bytes32 name, address indexed ballot, uint proposal);\r\n    event ConfigBallotCreated(address indexed proposer, bytes32 name, uint value, address indexed ballotAddr, uint reward);\r\n    event TokenBallotCreated(address indexed proposer, address indexed token, uint value, address indexed ballotAddr, uint reward);\r\n    event ProposalerRewardRateUpdated(uint oldVaue, uint newValue);\r\n    event RewardTransfered(address indexed from, address indexed to, uint value);\r\n    event TokenListed(address user, address token, uint amount);\r\n    event ListTokenAudited(address user, address token, uint status, uint burn, uint reward, uint refund);\r\n    event TokenAudited(address user, address token, uint status, bool result);\r\n    event RewardCollected(address indexed user, address indexed ballot, uint value);\r\n    event RewardReceived(address indexed user, uint value);\r\n\r\n    modifier onlyRewarder() {\r\n        require(msg.sender == rewardAddr, 'TomiGovernance: ONLY_REWARDER');\r\n        _;\r\n    }\r\n\r\n    constructor (address _tgas) TgasStaking(_tgas) public {\r\n    }\r\n\r\n    // called after deployment\r\n    function initialize(address _rewardAddr, address _configContractAddr, address _ballotFactoryAddr) external onlyOwner {\r\n        require(_rewardAddr != address(0) && _configContractAddr != address(0) && _ballotFactoryAddr != address(0), 'TomiGovernance: INPUT_ADDRESS_IS_ZERO');\r\n\r\n        rewardAddr = _rewardAddr;\r\n        configAddr = _configContractAddr;\r\n        ballotFactoryAddr = _ballotFactoryAddr;\r\n        lockTime = getConfigValue(ConfigNames.UNSTAKE_DURATION);\r\n    }\r\n\r\n    function audit(address _ballot) external returns (bool) {\r\n        if(ballotTypes[_ballot] == T_CONFIG) {\r\n            return auditConfig(_ballot);\r\n        } else if (ballotTypes[_ballot] == T_LIST_TOKEN) {\r\n            return auditListToken(_ballot);\r\n        } else if (ballotTypes[_ballot] == T_TOKEN) {\r\n            return auditToken(_ballot);\r\n        } else {\r\n            revert('TomiGovernance: UNKNOWN_TYPE');\r\n        }\r\n    }\r\n\r\n    function auditConfig(address _ballot) public returns (bool) {\r\n        bool result = ITomiBallot(_ballot).end();\r\n        require(result, 'TomiGovernance: NO_PASS');\r\n        uint value = ITomiBallot(_ballot).value();\r\n        bytes32 name = configBallots[_ballot];\r\n        result = ITomiConfig(configAddr).changeConfigValue(name, value);\r\n        if (name == ConfigNames.UNSTAKE_DURATION) {\r\n            lockTime = value;\r\n        } else if (name == ConfigNames.PRODUCE_TGAS_RATE) {\r\n            _changeAmountPerBlock(value);\r\n        }\r\n        emit ConfigAudited(name, _ballot, value);\r\n        return result;\r\n    }\r\n\r\n    function auditListToken(address _ballot) public returns (bool) {\r\n        bool result = ITomiBallot(_ballot).end();\r\n        address token = tokenBallots[_ballot];\r\n        address user = tokenUsers[token];\r\n        require(ITokenRegistry(configAddr).tokenStatus(token) == ITokenRegistry(configAddr).REGISTERED(), 'TomiGovernance: AUDITED');\r\n        uint status = result ? ITokenRegistry(configAddr).PENDING() : ITokenRegistry(configAddr).CLOSED();\r\n\t    uint amount = applyTokenOf[user][token];\r\n        (uint burnAmount, uint rewardAmount, uint refundAmount) = (0, 0, 0);\r\n        if (result) {\r\n            burnAmount = amount * getConfigValue(ConfigNames.LIST_TOKEN_SUCCESS_BURN_PRECENT) / ITomiConfig(configAddr).PERCENT_DENOMINATOR();\r\n            rewardAmount = amount - burnAmount;\r\n            if (burnAmount > 0) {\r\n                TransferHelper.safeTransfer(baseToken, address(0), burnAmount);\r\n                totalSupply = totalSupply.sub(burnAmount);\r\n            }\r\n            if (rewardAmount > 0) {\r\n                rewardOf[rewardAddr] = rewardOf[rewardAddr].add(rewardAmount);\r\n                ballotOf[_ballot] = ballotOf[_ballot].add(rewardAmount);\r\n                _rewardTransfer(rewardAddr, _ballot, rewardAmount);\r\n            }\r\n            ITokenRegistry(configAddr).publishToken(token);\r\n        } else {\r\n            burnAmount = amount * getConfigValue(ConfigNames.LIST_TOKEN_FAILURE_BURN_PRECENT) / ITomiConfig(configAddr).PERCENT_DENOMINATOR();\r\n            refundAmount = amount - burnAmount;\r\n            if (burnAmount > 0) TransferHelper.safeTransfer(baseToken, address(0), burnAmount);\r\n            if (refundAmount > 0) TransferHelper.safeTransfer(baseToken, user, refundAmount);\r\n            totalSupply = totalSupply.sub(amount);\r\n            ITokenRegistry(configAddr).updateToken(token, status);\r\n        }\r\n\t    emit ListTokenAudited(user, token, status, burnAmount, rewardAmount, refundAmount);\r\n        return result;\r\n    }\r\n\r\n    function auditToken(address _ballot) public returns (bool) {\r\n        bool result = ITomiBallot(_ballot).end();\r\n        uint status = ITomiBallot(_ballot).value();\r\n        address token = tokenBallots[_ballot];\r\n        address user = tokenUsers[token];\r\n        require(ITokenRegistry(configAddr).tokenStatus(token) != status, 'TomiGovernance: TOKEN_STATUS_NO_CHANGE');\r\n        if (result) {\r\n            ITokenRegistry(configAddr).updateToken(token, status);\r\n        } else {\r\n            status = ITokenRegistry(configAddr).tokenStatus(token);\r\n        }\r\n\t    emit TokenAudited(user, token, status, result);\r\n        return result;\r\n    }\r\n\r\n    function getConfigValue(bytes32 _name) public view returns (uint) {\r\n        return ITomiConfig(configAddr).getConfigValue(_name);\r\n    }\r\n\r\n    function createConfigBallot(bytes32 _name, uint _value, uint _amount, bool _wallet, string calldata _subject, string calldata _content) external returns (address) {\r\n        require(_value >= 0, 'TomiGovernance: INVALID_PARAMTERS');\r\n        { // avoids stack too deep errors\r\n        (uint minValue, uint maxValue, uint maxSpan, uint value, uint enable) = ITomiConfig(configAddr).getConfig(_name);\r\n        require(enable == 1, \"TomiGovernance: CONFIG_DISABLE\");\r\n        require(_value >= minValue && _value <= maxValue, \"TomiGovernance: OUTSIDE\");\r\n        uint span = _value >= value? (_value - value) : (value - _value);\r\n        require(maxSpan >= span, \"TomiGovernance: OVERSTEP\");\r\n        }\r\n        require(_amount >= getConfigValue(ConfigNames.PROPOSAL_TGAS_AMOUNT), \"TomiGovernance: NOT_ENOUGH_AMOUNT_TO_PROPOSAL\");\r\n        if(_amount > 0) {\r\n            _amount = _transferForBallot(_amount, _wallet);\r\n            rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_amount);\r\n        }\r\n        uint endBlockNumber = block.number + getConfigValue(ConfigNames.VOTE_DURATION);\r\n        address ballotAddr = ITomiBallotFactory(ballotFactoryAddr).create(msg.sender, _value, endBlockNumber, _subject, _content);\r\n        configBallots[ballotAddr] = _name;\r\n        uint reward = _createdBallot(ballotAddr, T_CONFIG);\r\n        emit ConfigBallotCreated(msg.sender, _name, _value, ballotAddr, reward);\r\n        return ballotAddr;\r\n    }\r\n\r\n    function createTokenBallot(address _token, uint _value, uint _amount, bool _wallet, string calldata _subject, string calldata _content) external returns (address) {\r\n        require(!_isDefaultToken(_token), 'TomiGovernance: DEFAULT_LIST_TOKENS_PROPOSAL_DENY');\r\n        uint status = ITokenRegistry(configAddr).tokenStatus(_token);\r\n        require(status == ITokenRegistry(configAddr).PENDING(), 'TomiGovernance: ONLY_ALLOW_PENDING');\r\n        require(_value == ITokenRegistry(configAddr).OPENED() || _value == ITokenRegistry(configAddr).CLOSED(), 'TomiGovernance: INVALID_STATUS');\r\n        require(status != _value, 'TomiGovernance: STATUS_NO_CHANGE');\r\n        require(_amount >= getConfigValue(ConfigNames.PROPOSAL_TGAS_AMOUNT), \"TomiGovernance: NOT_ENOUGH_AMOUNT_TO_PROPOSAL\");\r\n        if(_amount > 0) {\r\n            _amount = _transferForBallot(_amount, _wallet);\r\n            rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_amount);\r\n        }\r\n        address ballotAddr = _createTokenBallot(T_TOKEN, _token, _value, _subject, _content);\r\n        return ballotAddr;\r\n    }\r\n\r\n\tfunction listToken(address _token, uint _amount, bool _wallet, string calldata _subject, string calldata _content) external returns (address) {\r\n        uint status = ITokenRegistry(configAddr).tokenStatus(_token);\r\n        require(status == ITokenRegistry(configAddr).NONE() || status == ITokenRegistry(configAddr).CLOSED(), 'TomiGovernance: LISTED');\r\n\t    require(_amount >= getConfigValue(ConfigNames.LIST_TGAS_AMOUNT), \"TomiGovernance: NOT_ENOUGH_AMOUNT_TO_LIST\");\r\n\t    tokenUsers[_token] = msg.sender;\r\n        if(_amount > 0) {\r\n            applyTokenOf[msg.sender][_token] = _transferForBallot(_amount, _wallet);\r\n        }\r\n\t    ITokenRegistry(configAddr).registryToken(_token);\r\n        address ballotAddr = _createTokenBallot(T_LIST_TOKEN, _token, ITokenRegistry(configAddr).PENDING(), _subject, _content);\r\n\t    emit TokenListed(msg.sender, _token, _amount);\r\n        return ballotAddr;\r\n\t}\r\n\r\n    function _createTokenBallot(uint _type, address _token, uint _value, string memory _subject, string memory _content) private returns (address) {\r\n        uint endBlockNumber = block.number + getConfigValue(ConfigNames.VOTE_DURATION);\r\n        address ballotAddr = ITomiBallotFactory(ballotFactoryAddr).create(msg.sender, _value, endBlockNumber, _subject, _content);\r\n        uint reward = _createdBallot(ballotAddr, _type);\r\n        ballotOf[ballotAddr] = reward;\r\n        tokenBallots[ballotAddr] = _token;\r\n        emit TokenBallotCreated(msg.sender, _token, _value, ballotAddr, reward);\r\n        return ballotAddr;\r\n    }\r\n\r\n    function collectReward(address _ballot) external returns (uint) {\r\n        require(block.number >= ITomiBallot(_ballot).endBlockNumber(), \"TomiGovernance: NOT_YET_ENDED\");\r\n        require(!collectUsers[_ballot][msg.sender], 'TomiGovernance: REWARD_COLLECTED');\r\n        uint amount = getReward(_ballot);\r\n        _rewardTransfer(_ballot, msg.sender, amount);\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\r\n        stakingSupply = stakingSupply.add(amount);\r\n        rewardOf[msg.sender] = rewardOf[msg.sender].sub(amount);\r\n        collectUsers[_ballot][msg.sender] = true;\r\n        emit RewardCollected(msg.sender, _ballot, amount);\r\n    }\r\n\r\n    function getReward(address _ballot) public view returns (uint) {\r\n        if (block.number < ITomiBallot(_ballot).endBlockNumber() || collectUsers[_ballot][msg.sender]) {\r\n            return 0;\r\n        }\r\n        uint amount;\r\n        uint shares = ballotOf[_ballot];\r\n        if (ITomiBallot(_ballot).result()) {\r\n            uint extra;\r\n            uint rewardRate = getConfigValue(ConfigNames.VOTE_REWARD_PERCENT);\r\n            if ( rewardRate > 0) {\r\n               extra = shares * rewardRate / ITomiConfig(configAddr).PERCENT_DENOMINATOR();\r\n               shares -= extra;\r\n            }\r\n            if (msg.sender == ITomiBallot(_ballot).proposer()) {\r\n                amount = extra;\r\n            }\r\n        }\r\n\r\n        if (ITomiBallot(_ballot).total() > 0) {\r\n            amount += shares * ITomiBallot(_ballot).weight(msg.sender) / ITomiBallot(_ballot).total();\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    // TOMI TEST ONLY\r\n    // function addReward(uint _value) external onlyRewarder returns (bool) {\r\n    function addReward(uint _value) external returns (bool) {\r\n        require(_value > 0, 'TomiGovernance: ADD_REWARD_VALUE_IS_ZERO');\r\n        uint total = IERC20(baseToken).balanceOf(address(this));\r\n        uint diff = total.sub(totalSupply);\r\n        require(_value <= diff, 'TomiGovernance: ADD_REWARD_EXCEED');\r\n        rewardOf[rewardAddr] = rewardOf[rewardAddr].add(_value);\r\n        totalSupply = total;\r\n        emit RewardReceived(rewardAddr, _value);\r\n    }\r\n\r\n    function _rewardTransfer(address _from, address _to, uint _value) private returns (bool) {\r\n        require(_value >= 0 && rewardOf[_from] >= _value, 'TomiGovernance: INSUFFICIENT_BALANCE');\r\n        rewardOf[_from] = rewardOf[_from].sub(_value);\r\n        rewardOf[_to] = rewardOf[_to].add(_value);\r\n        emit RewardTransfered(_from, _to, _value);\r\n    }\r\n\r\n    function _isDefaultToken(address _token) internal returns (bool) {\r\n        address[] memory tokens = ITomiConfig(configAddr).getDefaultListTokens();\r\n        for(uint i = 0 ; i < tokens.length; i++){\r\n            if (tokens[i] == _token) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _transferForBallot(uint _amount, bool _wallet) internal returns (uint) {\r\n        if (_wallet) {\r\n            TransferHelper.safeTransferFrom(baseToken, msg.sender, address(this), _amount);\r\n            totalSupply += _amount;\r\n        } else {\r\n            _reduce(msg.sender, _amount);\r\n        }\r\n        return _amount;\r\n    }\r\n\r\n    function _createdBallot(address _ballot, uint _type) internal returns (uint) {\r\n        uint reward = rewardOf[rewardAddr];\r\n        ballotOf[_ballot] = reward;\r\n        _rewardTransfer(rewardAddr, _ballot, reward);\r\n        ballots.push(_ballot);\r\n        ballotTypes[_ballot] = _type;\r\n        return reward;\r\n    }\r\n\r\n    function ballotCount() external view returns (uint) {\r\n        return ballots.length;\r\n    }\r\n\r\n    function _changeAmountPerBlock(uint _value) internal returns (bool) {\r\n        return ITgas(baseToken).changeInterestRatePerBlock(_value);\r\n    }\r\n\r\n    function updateTgasGovernor(address _new) external onlyOwner {\r\n        ITgas(baseToken).upgradeGovernance(_new);\r\n    }\r\n\r\n    function upgradeApproveReward() external returns (uint) {\r\n        require(rewardOf[rewardAddr] > 0, 'TomiGovernance: UPGRADE_NO_REWARD');\r\n        require(ITomiConfig(configAddr).governor() != address(this), 'TomiGovernance: UPGRADE_NO_CHANGE');\r\n        TransferHelper.safeApprove(baseToken, ITomiConfig(configAddr).governor(), rewardOf[rewardAddr]);\r\n        return rewardOf[rewardAddr]; \r\n    }\r\n\r\n    function receiveReward(address _from, uint _value) external returns (bool) {\r\n        require(_value > 0, 'TomiGovernance: RECEIVE_REWARD_VALUE_IS_ZERO');\r\n        TransferHelper.safeTransferFrom(baseToken, _from, address(this), _value);\r\n        rewardOf[rewardAddr] += _value;\r\n        totalSupply += _value;\r\n        emit RewardReceived(_from, _value);\r\n        return true;\r\n    }\r\n\r\n}"
    },
    "contracts/interfaces/ITomiBallotFactory.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface ITomiBallotFactory {\r\n    function create(\r\n        address _proposer,\r\n        uint _value,\r\n        uint _endBlockNumber,\r\n        string calldata _subject,\r\n        string calldata _content\r\n    ) external returns (address);\r\n}"
    },
    "contracts/interfaces/ITomiBallot.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface ITomiBallot {\r\n    function proposer() external view returns(address);\r\n    function endBlockNumber() external view returns(uint);\r\n    function value() external view returns(uint);\r\n    function result() external view returns(bool);\r\n    function end() external returns (bool);\r\n    function total() external view returns(uint);\r\n    function weight(address user) external view returns (uint);\r\n}"
    },
    "contracts/modules/TgasStaking.sol": {
      "content": "pragma solidity >=0.5.16;\r\n\r\nimport '../libraries/TransferHelper.sol';\r\nimport '../libraries/SafeMath.sol';\r\nimport '../interfaces/IERC20.sol';\r\nimport '../interfaces/ITomiConfig.sol';\r\nimport '../modules/BaseToken.sol';\r\n\r\n\r\ncontract TgasStaking is BaseToken {\r\n    using SafeMath for uint;\r\n\r\n    uint public lockTime;\r\n    uint public totalSupply;\r\n    uint public stakingSupply;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => uint) public allowance;\r\n\r\n\r\n    constructor (address _baseToken) public {\r\n        initBaseToken(_baseToken);\r\n    }\r\n\r\n    function _add(address user, uint value) internal {\r\n        require(value > 0, 'ZERO');\r\n        balanceOf[user] = balanceOf[user].add(value);\r\n        stakingSupply = stakingSupply.add(value);\r\n        allowance[user] = block.number;\r\n    }\r\n\r\n    function _reduce(address user, uint value) internal {\r\n        require(balanceOf[user] >= value && value > 0, 'TgasStaking: INSUFFICIENT_BALANCE');\r\n        balanceOf[user] = balanceOf[user].sub(value);\r\n        stakingSupply = stakingSupply.sub(value);\r\n    }\r\n\r\n    function deposit(uint _amount) external returns (bool) {\r\n        TransferHelper.safeTransferFrom(baseToken, msg.sender, address(this), _amount);\r\n        _add(msg.sender, _amount);\r\n        totalSupply = IERC20(baseToken).balanceOf(address(this));\r\n        return true;\r\n    }\r\n\r\n    function withdraw(uint _amount) external returns (bool) {\r\n        require(block.number > allowance[msg.sender] + lockTime, 'TgasStaking: NOT_DUE');\r\n        TransferHelper.safeTransfer(baseToken, msg.sender, _amount);\r\n        _reduce(msg.sender, _amount);\r\n        totalSupply = IERC20(baseToken).balanceOf(address(this));\r\n        return true;\r\n    }\r\n\r\n}"
    },
    "contracts/modules/BaseToken.sol": {
      "content": "\r\npragma solidity >=0.5.16;\r\n\r\ncontract BaseToken {\r\n    address public baseToken;\r\n\r\n    // called after deployment\r\n    function initBaseToken(address _baseToken) internal {\r\n        require(baseToken == address(0), 'INITIALIZED');\r\n        require(_baseToken != address(0), 'ADDRESS_IS_ZERO');\r\n        baseToken = _baseToken;  // it should be tgas token address\r\n    }\r\n}"
    },
    "contracts/TomiDelegate.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\nimport './TomiLP.sol';\r\nimport './libraries/TransferHelper.sol';\r\nimport './libraries/SafeMath.sol';\r\nimport './modules/Ownable.sol';\r\nimport './interfaces/ITomiEscrow.sol';\r\n\r\ninterface ITomiLP {\r\n    function addLiquidity(\r\n        address user,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline) external returns (\r\n            uint256 _amountA,\r\n            uint256 _amountB,\r\n            uint256 _liquidity\r\n        );\r\n    function removeLiquidity(\r\n        address user,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline) external returns (\r\n            uint256 _amountA,\r\n            uint256 _amountB\r\n        );\r\n    function addLiquidityETH(\r\n        address user,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        uint256 deadline) external payable returns (\r\n            uint256 _amountToken,\r\n            uint256 _amountETH,\r\n            uint256 _liquidity\r\n        );\r\n    function removeLiquidityETH (\r\n        address user,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        uint256 deadline) external returns (uint256 _amountToken, uint256 _amountETH);\r\n    function initialize(address _tokenA, address _tokenB, address _DGAS, address _POOL, address _PLATFORM, address _WETH, address _DELEGATE) external;\r\n    function upgrade(address _PLATFORM) external;\r\n    function tokenA() external returns(address);\r\n    function mintRewardForUser(address _userAddress) external returns (uint rewardAmount);\r\n}\r\n\r\ncontract TomiDelegate is Ownable{\r\n    using SafeMath for uint;\r\n    \r\n    address public PLATFORM;\r\n    address public POOL;\r\n    address public TGAS;\r\n    address public WETH;\r\n    mapping(address => mapping(address => address)) public getPair;\r\n    address[] public allPairs;\r\n    mapping(address => bool) public isPair;\r\n    mapping(address => address[]) public playerPairs;\r\n    mapping(address => mapping(address => bool)) public isAddPlayerPair;\r\n\r\n    bytes32 public contractCodeHash;\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\r\n    event RewardMinted(address indexed user, address indexed shareToken, uint amount);\r\n    \r\n    constructor(address _PLATFORM, address _POOL, address _TGAS, address _WETH) public {\r\n        PLATFORM = _PLATFORM;\r\n        POOL = _POOL;\r\n        TGAS = _TGAS;\r\n        WETH = _WETH;\r\n    }\r\n    \r\n    receive() external payable {\r\n    }\r\n    \r\n    function upgradePlatform(address _PLATFORM) external onlyOwner {\r\n        for(uint i = 0; i < allPairs.length;i++) {\r\n            ITomiLP(allPairs[i]).upgrade(_PLATFORM);\r\n        }\r\n    }\r\n\r\n    function allPairsLength() external view returns (uint256) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    function getPlayerPairCount(address player) external view returns (uint256) {\r\n        return playerPairs[player].length;\r\n    }\r\n\r\n    function _addPlayerPair(address _user, address _pair) internal {\r\n        if (isAddPlayerPair[_user][_pair] == false) {\r\n            isAddPlayerPair[_user][_pair] = true;\r\n            playerPairs[_user].push(_pair);\r\n        }\r\n    }\r\n\r\n    function addPlayerPair(address _user) external {\r\n        require(isPair[msg.sender], 'addPlayerPair Forbidden');\r\n        _addPlayerPair(_user, msg.sender);\r\n    }\r\n    \r\n    function approveContract(address token, address spender, uint amount) internal {\r\n        uint allowAmount = IERC20(token).totalSupply();\r\n        if(allowAmount < amount) {\r\n            allowAmount = amount;\r\n        }\r\n        if(IERC20(token).allowance(address(this), spender) < amount) {\r\n            TransferHelper.safeApprove(token, spender, allowAmount);\r\n        }\r\n    }\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        uint256 deadline\r\n        ) payable external returns (\r\n            uint256 _amountToken,\r\n            uint256 _amountETH,\r\n            uint256 _liquidity\r\n        ) {\r\n        address pair = getPair[token][WETH];\r\n            if(pair == address(0)) {\r\n                pair = _createPair(token, WETH);\r\n            }\r\n            \r\n            _addPlayerPair(msg.sender, pair);\r\n\r\n            TransferHelper.safeTransferFrom(token, msg.sender, address(this), amountTokenDesired);\r\n            // approveContract(token, pair, amountTokenDesired);\r\n            TransferHelper.safeApprove(token, pair, amountTokenDesired);\r\n            (_amountToken, _amountETH, _liquidity) = ITomiLP(pair).addLiquidityETH{value: msg.value}(msg.sender, amountTokenDesired, amountTokenMin, amountETHMin, deadline);\r\n    }\r\n    \r\n    \r\n    \r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline) external returns (\r\n            uint256 _amountA,\r\n            uint256 _amountB,\r\n            uint256 _liquidity\r\n        ) {\r\n            address pair = getPair[tokenA][tokenB];\r\n            if(pair == address(0)) {\r\n                pair = _createPair(tokenA, tokenB);\r\n            }\r\n\r\n            _addPlayerPair(msg.sender, pair);\r\n\r\n            if(tokenA != ITomiLP(pair).tokenA()) {\r\n                (tokenA, tokenB) = (tokenB, tokenA);\r\n                (amountA, amountB, amountAMin, amountBMin) = (amountB, amountA, amountBMin, amountAMin);\r\n            }\r\n            \r\n            TransferHelper.safeTransferFrom(tokenA, msg.sender, address(this), amountA);\r\n            TransferHelper.safeTransferFrom(tokenB, msg.sender, address(this), amountB);\r\n            approveContract(tokenA, pair, amountA);\r\n            approveContract(tokenB, pair, amountB);\r\n\r\n            (_amountA, _amountB, _liquidity) = ITomiLP(pair).addLiquidity(msg.sender, amountA, amountB, amountAMin, amountBMin, deadline);\r\n            if(tokenA != ITomiLP(pair).tokenA()) {\r\n                (_amountA, _amountB) = (_amountB, _amountA);\r\n            }\r\n    }\r\n    \r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        uint deadline\r\n        ) external returns (uint _amountToken, uint _amountETH) {\r\n            address pair = getPair[token][WETH];\r\n            (_amountToken, _amountETH) = ITomiLP(pair).removeLiquidityETH(msg.sender, liquidity, amountTokenMin, amountETHMin, deadline);\r\n        }\r\n    \r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline) external returns (\r\n            uint256 _amountA,\r\n            uint256 _amountB\r\n        ) {\r\n        address pair = getPair[tokenA][tokenB];\r\n        (_amountA, _amountB) = ITomiLP(pair).removeLiquidity(msg.sender, liquidity, amountAMin, amountBMin, deadline);\r\n    }\r\n\r\n    function _createPair(address tokenA, address tokenB) internal returns (address pair){\r\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'TOMI FACTORY: ZERO_ADDRESS');\r\n        require(getPair[token0][token1] == address(0), 'TOMI FACTORY: PAIR_EXISTS'); // single check is sufficient\r\n        bytes memory bytecode = type(TomiLP).creationCode;\r\n        if (uint256(contractCodeHash) == 0) {\r\n            contractCodeHash = keccak256(bytecode);\r\n        }\r\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n        assembly {\r\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        isPair[pair] = true;\r\n        ITomiLP(pair).initialize(token0, token1, TGAS, POOL, PLATFORM, WETH, address(this));\r\n        getPair[token0][token1] = pair;\r\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\r\n        allPairs.push(pair);\r\n        emit PairCreated(token0, token1, pair, allPairs.length);\r\n    }\r\n\r\n    function mintRewardByPair(address _escrow, address _pair, address _tokenAddress) external returns(uint) {\r\n        uint amount = ITomiLP(_pair).mintRewardForUser(msg.sender);\r\n        require(amount > 0, \"TomiDelegate::Your reward is not enough to claim!\");\r\n        \r\n        TransferHelper.safeTransfer(TGAS, address(0), amount);\r\n        ITomiEscrow(_escrow).withdrawReward(_tokenAddress, amount, msg.sender);\r\n        emit RewardMinted(msg.sender, _tokenAddress, amount);\r\n\r\n        return amount;\r\n    }\r\n}"
    },
    "contracts/TomiLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\nimport './libraries/SafeMath.sol';\r\nimport './modules/BaseShareField.sol';\r\n\r\ninterface ITomiPool {\r\n    function queryReward(address _pair, address _user) external view returns(uint);\r\n    function claimReward(address _pair, address _rewardToken) external;\r\n}\r\n\r\ninterface ITomiPair {\r\n    function queryReward() external view returns (uint256 rewardAmount, uint256 blockNumber);\r\n    function mintReward() external returns (uint256 userReward);\r\n}\r\n\r\ninterface ITomiDelegate {\r\n    function addPlayerPair(address _user) external;\r\n}\r\n\r\ninterface ITomiPlatform{\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 _amountA,\r\n            uint256 _amountB,\r\n            uint256 _liquidity\r\n        );\r\n        \r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 _amountToken,\r\n            uint256 _amountETH,\r\n            uint256 _liquidity\r\n        );\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n    \r\n    function pairFor(address tokenA, address tokenB) external view returns (address);\r\n}\r\n\r\ncontract TomiLP is BaseShareField {\r\n    // ERC20 Start\r\n    \r\n    using SafeMath for uint;\r\n\r\n    string public constant name = 'Tomi LP';\r\n    string public constant symbol = 'BLP';\r\n    uint8 public constant decimals = 18;\r\n    uint public totalSupply;\r\n    \r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    event Mint(address indexed user, uint amount);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    \r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n    \r\n    receive() external payable {\r\n    }\r\n    \r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        require(balanceOf[from] >= value, 'ERC20Token: INSUFFICIENT_BALANCE');\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        if (to == address(0)) { // burn\r\n            totalSupply = totalSupply.sub(value);\r\n        }\r\n\r\n        ITomiDelegate(owner).addPlayerPair(to);\r\n        _mintReward();\r\n        _decreaseProductivity(from, value);\r\n        _increaseProductivity(to, value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external returns (bool) {\r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool) {\r\n        require(allowance[from][msg.sender] >= value, 'ERC20Token: INSUFFICIENT_ALLOWANCE');\r\n        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }    \r\n    \r\n    // ERC20 End\r\n    \r\n    \r\n    address public owner;\r\n    address public POOL;\r\n    address public PLATFORM;\r\n    address public tokenA;\r\n    address public tokenB;\r\n    address public WETH;\r\n    address public DELEGATE;\r\n    \r\n    event AddLiquidity (address indexed user, uint amountA, uint amountB, uint value);\r\n    event RemoveLiquidity (address indexed user, uint amountA, uint amountB, uint value);\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function initialize(address _tokenA, address _tokenB, address _DGAS, address _POOL, address _PLATFORM, address _WETH, address _DELEGATE) external {\r\n        require(msg.sender == owner, \"Demax LP Forbidden\");\r\n        tokenA = _tokenA;\r\n        tokenB = _tokenB;\r\n        _setShareToken(_DGAS);\r\n        PLATFORM = _PLATFORM;\r\n        POOL = _POOL;\r\n        WETH = _WETH;\r\n        DELEGATE = _DELEGATE;\r\n    }\r\n \r\n    function upgrade(address _PLATFORM) external {\r\n        require(msg.sender == owner, \"Tomi LP Forbidden\");\r\n        PLATFORM = _PLATFORM;\r\n    }\r\n\r\n    function approveContract(address token, address spender, uint amount) internal {\r\n        uint allowAmount = IERC20(token).totalSupply();\r\n        if(allowAmount < amount) {\r\n            allowAmount = amount;\r\n        }\r\n        if(IERC20(token).allowance(address(this), spender) < amount) {\r\n            TransferHelper.safeApprove(token, spender, allowAmount);\r\n        }\r\n    }\r\n    \r\n    function addLiquidityETH(\r\n        address user,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        uint256 deadline) external payable returns (\r\n            uint256 _amountToken,\r\n            uint256 _amountETH,\r\n            uint256 _liquidity\r\n        ) {\r\n           require(msg.sender == owner, \"Tomi LP Forbidden\");\r\n           require(tokenA == WETH || tokenB == WETH, \"INVALID CALL\");\r\n           address token = tokenA == WETH ? tokenB: tokenA;\r\n           approveContract(token, PLATFORM, amountTokenDesired);\r\n           TransferHelper.safeTransferFrom(token, msg.sender, address(this), amountTokenDesired);\r\n           \r\n           (_amountToken, _amountETH, _liquidity) = ITomiPlatform(PLATFORM).addLiquidityETH{value: msg.value}(token, amountTokenDesired, amountTokenMin, amountETHMin, deadline);\r\n           \r\n           if(amountTokenDesired > _amountToken) {\r\n                TransferHelper.safeTransfer(token, user, amountTokenDesired.sub(_amountToken));\r\n            }\r\n            \r\n            if(msg.value > _amountETH) {\r\n                TransferHelper.safeTransferETH(user, msg.value.sub(_amountETH));\r\n            }\r\n        _mintReward();\r\n        _mint(user, _liquidity);\r\n        _increaseProductivity(user, _liquidity);\r\n        (uint amountA, uint amountB) = token == tokenA ? (_amountToken, _amountETH): (_amountETH, _amountToken);\r\n        emit AddLiquidity (user, amountA, amountB, _liquidity);\r\n    }\r\n    \r\n    function addLiquidity(\r\n        address user,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline) external returns (\r\n            uint256 _amountA,\r\n            uint256 _amountB,\r\n            uint256 _liquidity\r\n        ) {\r\n            require(msg.sender == owner, \"Tomi LP Forbidden\");\r\n            approveContract(tokenA, PLATFORM, amountA);\r\n            approveContract(tokenB, PLATFORM, amountB);\r\n            TransferHelper.safeTransferFrom(tokenA, msg.sender, address(this), amountA);\r\n            TransferHelper.safeTransferFrom(tokenB, msg.sender, address(this), amountB);\r\n        (_amountA, _amountB, _liquidity) = ITomiPlatform(PLATFORM).addLiquidity(tokenA, tokenB, amountA, amountB, amountAMin, amountBMin, deadline);\r\n        if(amountA > _amountA) {\r\n            TransferHelper.safeTransfer(tokenA, user, amountA.sub(_amountA));\r\n        }\r\n        \r\n        if(amountB > _amountB) {\r\n            TransferHelper.safeTransfer(tokenB, user, amountB.sub(_amountB));\r\n        }\r\n        \r\n        _mintReward();\r\n        _mint(user, _liquidity);\r\n        _increaseProductivity(user, _liquidity);\r\n        emit AddLiquidity (user, _amountA, _amountB, _liquidity);\r\n    }\r\n    \r\n    function removeLiquidityETH (\r\n        address user,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        uint256 deadline) external returns (uint256 _amountToken, uint256 _amountETH) {\r\n         require(msg.sender == owner, \"Tomi LP Forbidden\");\r\n         require(tokenA == WETH || tokenB == WETH, \"INVALID CALL\");\r\n         address token = tokenA == WETH ? tokenB: tokenA;\r\n           \r\n        (_amountToken, _amountETH) = ITomiPlatform(PLATFORM).removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, user, deadline);\r\n         \r\n        _mintReward();\r\n        _burn(user, liquidity);\r\n        _decreaseProductivity(user, liquidity);\r\n        (uint amountA, uint amountB) = token == tokenA ? (_amountToken, _amountETH): (_amountETH, _amountToken);\r\n        emit RemoveLiquidity (user, amountA, amountB, liquidity);\r\n    }\r\n    \r\n    function removeLiquidity(\r\n        address user,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        uint256 deadline) external returns (\r\n            uint256 _amountA,\r\n            uint256 _amountB\r\n        ) {\r\n            require(msg.sender == owner, \"Tomi LP Forbidden\");\r\n        (_amountA, _amountB) = ITomiPlatform(PLATFORM).removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, user, deadline);\r\n        \r\n        _mintReward();\r\n        _burn(user, liquidity);\r\n        _decreaseProductivity(user, liquidity);\r\n        emit RemoveLiquidity (user, _amountA, _amountB, liquidity);\r\n    }\r\n    \r\n    function _currentReward() internal override view returns (uint) {\r\n        address pair = ITomiPlatform(PLATFORM).pairFor(tokenA, tokenB);\r\n        uint countractAmount = mintedShare.add(IERC20(shareToken).balanceOf(address(this))).sub(totalShare);\r\n        if(pair != address(0)) {\r\n            uint poolAmount = ITomiPool(POOL).queryReward(pair, address(this));\r\n            (uint pairAmount, ) = ITomiPair(pair).queryReward();\r\n            return countractAmount.add(poolAmount).add(pairAmount);\r\n        } else {\r\n            return countractAmount;\r\n        }\r\n    }\r\n    \r\n    function _mintReward() internal {\r\n        address pair = ITomiPlatform(PLATFORM).pairFor(tokenA, tokenB);\r\n        if(pair != address(0)) {\r\n            uint poolAmount = ITomiPool(POOL).queryReward(pair, address(this));\r\n            (uint pairAmount, ) = ITomiPair(pair).queryReward();\r\n            if(poolAmount > 0) {\r\n                ITomiPool(POOL).claimReward(pair, shareToken);\r\n            }\r\n            \r\n            if(pairAmount > 0) {\r\n                ITomiPair(pair).mintReward();\r\n            }\r\n        } \r\n    }\r\n    \r\n    function queryReward() external view returns (uint) {\r\n        return _takeWithAddress(msg.sender);\r\n    }\r\n    \r\n\r\n    function mintRewardForUser(address _userAddress) external returns (uint amount) {\r\n        require(msg.sender == DELEGATE, \"TomiPair::Your permission not be able to do!\");\r\n        _mintReward();\r\n        amount = _mint(_userAddress);\r\n        emit Mint(msg.sender, amount);\r\n    }\r\n}"
    },
    "contracts/interfaces/ITomiEscrow.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface ITomiEscrow {\r\n    function setShareToken(address _tokenAddress, uint _dgasRate) external;\r\n    function depositReward(address _tokenAddress, uint _reward) external;\r\n    function withdrawReward(address _shareToken, uint _amount, address _to) external;\r\n    function updateShareTokenRate(address _tokenAddress, uint _dgasRate) external;\r\n    function shareTokenExisted(address _tokenAddress) external view returns(bool);\r\n    function shareTokenReward(address _tokenAddress) external view returns(uint);\r\n}\r\n\r\n"
    },
    "contracts/modules/BaseShareField.sol": {
      "content": "pragma solidity >=0.6.6;\r\nimport '../interfaces/ERC2917-Interface.sol';\r\nimport '../libraries/SafeMath.sol';\r\nimport '../libraries/TransferHelper.sol';\r\n\r\ncontract BaseShareField {\r\n    using SafeMath for uint;\r\n    \r\n    uint totalProductivity;\r\n    uint accAmountPerShare;\r\n    \r\n    uint public totalShare;\r\n    uint public mintedShare;\r\n    uint public mintCumulation;\r\n    \r\n    address public shareToken;\r\n    \r\n    struct UserInfo {\r\n        uint amount;     // How many tokens the user has provided.\r\n        uint rewardDebt; // Reward debt. \r\n        uint rewardEarn; // Reward earn and not minted\r\n    }\r\n\r\n    mapping(address => UserInfo) public users;\r\n    \r\n    function _setShareToken(address _shareToken) internal {\r\n        shareToken = _shareToken;\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function _update() internal virtual {\r\n        if (totalProductivity == 0) {\r\n            totalShare = totalShare.add(_currentReward());\r\n            return;\r\n        }\r\n        \r\n        uint256 reward = _currentReward();\r\n        accAmountPerShare = accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\r\n        totalShare = totalShare.add(reward);\r\n    }\r\n    \r\n    function _currentReward() internal virtual view returns (uint) {\r\n        return mintedShare.add(IERC20(shareToken).balanceOf(address(this))).sub(totalShare);\r\n    }\r\n    \r\n    // Audit user's reward to be up-to-date\r\n    function _audit(address user) internal virtual {\r\n        UserInfo storage userInfo = users[user];\r\n        if (userInfo.amount > 0) {\r\n            uint pending = userInfo.amount.mul(accAmountPerShare).div(1e12).sub(userInfo.rewardDebt);\r\n            userInfo.rewardEarn = userInfo.rewardEarn.add(pending);\r\n            mintCumulation = mintCumulation.add(pending);\r\n            userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\r\n        }\r\n    }\r\n\r\n    // External function call\r\n    // This function increase user's productivity and updates the global productivity.\r\n    // the users' actual share percentage will calculated by:\r\n    // Formula:     user_productivity / global_productivity\r\n    function _increaseProductivity(address user, uint value) internal virtual returns (bool) {\r\n        require(value > 0, 'PRODUCTIVITY_VALUE_MUST_BE_GREATER_THAN_ZERO');\r\n\r\n        UserInfo storage userInfo = users[user];\r\n        _update();\r\n        _audit(user);\r\n\r\n        totalProductivity = totalProductivity.add(value);\r\n\r\n        userInfo.amount = userInfo.amount.add(value);\r\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\r\n        return true;\r\n    }\r\n\r\n    // External function call \r\n    // This function will decreases user's productivity by value, and updates the global productivity\r\n    // it will record which block this is happenning and accumulates the area of (productivity * time)\r\n    function _decreaseProductivity(address user, uint value) internal virtual returns (bool) {\r\n        UserInfo storage userInfo = users[user];\r\n        require(value > 0 && userInfo.amount >= value, 'INSUFFICIENT_PRODUCTIVITY');\r\n        \r\n        _update();\r\n        _audit(user);\r\n        \r\n        userInfo.amount = userInfo.amount.sub(value);\r\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\r\n        totalProductivity = totalProductivity.sub(value);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function _takeWithAddress(address user) internal view returns (uint) {\r\n        UserInfo storage userInfo = users[user];\r\n        uint _accAmountPerShare = accAmountPerShare;\r\n        // uint256 lpSupply = totalProductivity;\r\n        if (totalProductivity != 0) {\r\n            uint reward = _currentReward();\r\n            _accAmountPerShare = _accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\r\n        }\r\n        return userInfo.amount.mul(_accAmountPerShare).div(1e12).add(userInfo.rewardEarn).sub(userInfo.rewardDebt);\r\n    }\r\n\r\n    // External function call\r\n    // When user calls this function, it will calculate how many token will mint to user from his productivity * time\r\n    // Also it calculates global token supply from last time the user mint to this time.\r\n    function _mint(address user) internal virtual returns (uint) {\r\n        _update();\r\n        _audit(user);\r\n        require(users[user].rewardEarn > 0, \"NOTHING TO MINT\");\r\n        uint amount = users[user].rewardEarn;\r\n        TransferHelper.safeTransfer(shareToken, msg.sender, amount);\r\n        users[user].rewardEarn = 0;\r\n        mintedShare += amount;\r\n        return amount;\r\n    }\r\n\r\n    // Returns how many productivity a user has and global has.\r\n    function getProductivity(address user) public virtual view returns (uint, uint) {\r\n        return (users[user].amount, totalProductivity);\r\n    }\r\n\r\n    // Returns the current gorss product rate.\r\n    function interestsPerBlock() public virtual view returns (uint) {\r\n        return accAmountPerShare;\r\n    }\r\n    \r\n}"
    },
    "contracts/interfaces/ERC2917-Interface.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\nimport '../interfaces/IERC20.sol';\r\n\r\ninterface IERC2917 is IERC20 {\r\n\r\n    /// @dev This emit when interests amount per block is changed by the owner of the contract.\r\n    /// It emits with the old interests amount and the new interests amount.\r\n    event InterestRatePerBlockChanged (uint oldValue, uint newValue);\r\n\r\n    /// @dev This emit when a users' productivity has changed\r\n    /// It emits with the user's address and the the value after the change.\r\n    event ProductivityIncreased (address indexed user, uint value);\r\n\r\n    /// @dev This emit when a users' productivity has changed\r\n    /// It emits with the user's address and the the value after the change.\r\n    event ProductivityDecreased (address indexed user, uint value);\r\n\r\n    /// @dev Return the current contract's interests rate per block.\r\n    /// @return The amount of interests currently producing per each block.\r\n    function interestsPerBlock() external view returns (uint);\r\n\r\n    /// @notice Change the current contract's interests rate.\r\n    /// @dev Note the best practice will be restrict the gross product provider's contract address to call this.\r\n    /// @return The true/fase to notice that the value has successfully changed or not, when it succeed, it will emite the InterestRatePerBlockChanged event.\r\n    function changeInterestRatePerBlock(uint value) external returns (bool);\r\n\r\n    /// @notice It will get the productivity of given user.\r\n    /// @dev it will return 0 if user has no productivity proved in the contract.\r\n    /// @return user's productivity and overall productivity.\r\n    function getProductivity(address user) external view returns (uint, uint);\r\n\r\n    /// @notice increase a user's productivity.\r\n    /// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\r\n    /// @return true to confirm that the productivity added success.\r\n    function increaseProductivity(address user, uint value) external returns (bool);\r\n\r\n    /// @notice decrease a user's productivity.\r\n    /// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\r\n    /// @return true to confirm that the productivity removed success.\r\n    function decreaseProductivity(address user, uint value) external returns (bool);\r\n\r\n    /// @notice take() will return the interests that callee will get at current block height.\r\n    /// @dev it will always calculated by block.number, so it will change when block height changes.\r\n    /// @return amount of the interests that user are able to mint() at current block height.\r\n    function take() external view returns (uint);\r\n\r\n    /// @notice similar to take(), but with the block height joined to calculate return.\r\n    /// @dev for instance, it returns (_amount, _block), which means at block height _block, the callee has accumulated _amount of interests.\r\n    /// @return amount of interests and the block height.\r\n    function takeWithBlock() external view returns (uint, uint);\r\n\r\n    /// @notice mint the avaiable interests to callee.\r\n    /// @dev once it mint, the amount of interests will transfer to callee's address.\r\n    /// @return the amount of interests minted.\r\n    function mint() external returns (uint);\r\n}\r\n"
    },
    "contracts/TomiEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\nimport \"./modules/Upgradable.sol\";\r\nimport './libraries/SafeMath.sol';\r\nimport './libraries/TransferHelper.sol';\r\nimport './modules/Pausable.sol';\r\nimport './interfaces/IERC20.sol';\r\n\r\ncontract TomiEscrow is UpgradableProduct, Pausable {\r\n    using SafeMath for uint;\r\n\r\n    // Token will be used for rewarding \r\n    struct ShareToken {\r\n        uint dgasRate;\r\n    }\r\n\r\n    // Address of DELEGATE Smart Contract\r\n    address public DELEGATE;\r\n    // Enable emergency withdraw or not \r\n    bool public ableToEmergencyWithdraw;\r\n\r\n    // Share token with rate config and remaining reward\r\n    mapping(address => ShareToken) public shareTokens;\r\n\r\n    // -----------------------------------------\r\n    // TomiEscrow's event\r\n    // -----------------------------------------\r\n    event RewardWithdraw(address shareToken, uint reward, address to);\r\n    event DgasToTokenRated(uint oldRate, uint newRate);\r\n    event ShareTokenUpdated(address tokenAddress, uint dgasRate);\r\n    event ShareTokenSettled(address tokenAddress, uint dgasRate);\r\n    event EmergencyWithdrawStatusUpdate(bool newState);\r\n    event EmergencyWithdraw(address to, uint totalWithdraw);\r\n\r\n    // -----------------------------------------\r\n    // -----------------------------------------\r\n\r\n    constructor(address _DELEGATE) UpgradableProduct() public {\r\n        DELEGATE = _DELEGATE;\r\n        ableToEmergencyWithdraw = false;\r\n    }\r\n\r\n    modifier onlyDelegate() {\r\n        require(msg.sender == DELEGATE, \"TomiEscrow::FORBIDDEN\");\r\n        _;\r\n    }\r\n\r\n    function setEmergencyWithdrawStatus(bool _enableEmergencyWithdraw) public requireImpl {\r\n        ableToEmergencyWithdraw = _enableEmergencyWithdraw;\r\n        emit EmergencyWithdrawStatusUpdate(ableToEmergencyWithdraw);\r\n    }\r\n\r\n    function setShareToken(address _tokenAddress, uint _dgasRate) public requireImpl {\r\n        require(!shareTokenExisted(_tokenAddress), \"TomiEscrow::Share token address already exist!\");\r\n        require(_tokenAddress != address(0), \"TomiEscrow::Share token address is not illegal\");\r\n        require(_dgasRate != uint(0), \"TomiEscrow::Share token rate is not illegal\");\r\n        shareTokens[_tokenAddress] = ShareToken(_dgasRate);\r\n\r\n        emit ShareTokenSettled(_tokenAddress, _dgasRate);\r\n    }\r\n\r\n    function emergencyWithdrawERC20(address _tokenAddress) public requireImpl whenPaused {\r\n        require(ableToEmergencyWithdraw, \"TomiEscrow::Emergency withdraw is disabled\");\r\n        uint totalReward = shareTokenReward(_tokenAddress);\r\n        require(totalReward > 0, \"TomiEscrow::Nothing to withdraw\");\r\n        \r\n        TransferHelper.safeTransfer(_tokenAddress, msg.sender, totalReward);\r\n        emit EmergencyWithdraw(msg.sender, totalReward);\r\n    }\r\n\r\n    function withdrawReward(address _tokenAddress, uint _amount, address _to) public whenNotPaused onlyDelegate {\r\n        require(shareTokenExisted(_tokenAddress), \"TomiEscrow::Share token not existed!\");\r\n        uint totalReward = shareTokenReward(_tokenAddress);\r\n        uint DGasToToken = shareTokens[_tokenAddress].dgasRate;\r\n        \r\n        require(totalReward >= _amount, \"TomiEscrow::Not enough rewards for withdraw!\");\r\n        \r\n        uint dgasToReward = _amount.mul(DGasToToken);\r\n        TransferHelper.safeTransfer(_tokenAddress, _to, dgasToReward);\r\n\r\n        emit RewardWithdraw(_tokenAddress, dgasToReward, _to);\r\n    }\r\n\r\n    function updateShareTokenRate(address _tokenAddress, uint _dgasRate) public requireImpl {\r\n        require(shareTokenExisted(_tokenAddress), \"TomiEscrow::Share token not existed!\");\r\n        require(_dgasRate != uint(0), \"TomiEscrow::Share token rate is not illegal\");\r\n        require( shareTokens[_tokenAddress].dgasRate != _dgasRate, \"TomiEscrow::Not be able to set same Dgas rate!\");\r\n\r\n        shareTokens[_tokenAddress].dgasRate = _dgasRate;\r\n\r\n        emit ShareTokenUpdated(_tokenAddress, _dgasRate);\r\n    }\r\n\r\n    function shareTokenExisted(address _tokenAddress) public view returns(bool) {\r\n        require(_tokenAddress != address(0), \"TomiEscrow::Share token address is illegal\");\r\n        return shareTokens[_tokenAddress].dgasRate != uint(0);\r\n    }\r\n\r\n    function shareTokenReward(address _tokenAddress) public view returns(uint) {\r\n        return IERC20(_tokenAddress).balanceOf(address(this));\r\n    }\r\n\r\n    function pause() external requireImpl {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external requireImpl {\r\n        _unpause();\r\n    }\r\n\r\n    fallback() external {\r\n\r\n    }\r\n}\r\n"
    },
    "contracts/modules/Upgradable.sol": {
      "content": "pragma solidity >=0.5.16;\r\n\r\ncontract UpgradableProduct {\r\n    address public impl;\r\n\r\n    event ImplChanged(address indexed _oldImpl, address indexed _newImpl);\r\n\r\n    constructor() public {\r\n        impl = msg.sender;\r\n    }\r\n\r\n    modifier requireImpl() {\r\n        require(msg.sender == impl, 'FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    function upgradeImpl(address _newImpl) public requireImpl {\r\n        require(_newImpl != address(0), 'INVALID_ADDRESS');\r\n        require(_newImpl != impl, 'NO_CHANGE');\r\n        address lastImpl = impl;\r\n        impl = _newImpl;\r\n        emit ImplChanged(lastImpl, _newImpl);\r\n    }\r\n}\r\n\r\ncontract UpgradableGovernance {\r\n    address public governor;\r\n\r\n    event GovernorChanged(address indexed _oldGovernor, address indexed _newGovernor);\r\n\r\n    constructor() public {\r\n        governor = msg.sender;\r\n    }\r\n\r\n    modifier requireGovernor() {\r\n        require(msg.sender == governor, 'FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    function upgradeGovernance(address _newGovernor) public requireGovernor {\r\n        require(_newGovernor != address(0), 'INVALID_ADDRESS');\r\n        require(_newGovernor != governor, 'NO_CHANGE');\r\n        address lastGovernor = governor;\r\n        governor = _newGovernor;\r\n        emit GovernorChanged(lastGovernor, _newGovernor);\r\n    }\r\n}"
    },
    "contracts/modules/Pausable.sol": {
      "content": "  \r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.5.16;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() public {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}"
    },
    "contracts/modules/ERC2917Impl.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\nimport '../interfaces/ERC2917-Interface.sol';\r\nimport '../modules/Upgradable.sol';\r\nimport '../libraries/SafeMath.sol';\r\n\r\n/*\r\n    The Objective of ERC2917 Demo is to implement a decentralized staking mechanism, which calculates users' share\r\n    by accumulating productiviy * time. And calculates users revenue from anytime t0 to t1 by the formula below:\r\n\r\n        user_accumulated_productivity(time1) - user_accumulated_productivity(time0)\r\n       _____________________________________________________________________________  * (gross_product(t1) - gross_product(t0))\r\n       total_accumulated_productivity(time1) - total_accumulated_productivity(time0)\r\n\r\n*/\r\ncontract ERC2917Impl is IERC2917, UpgradableProduct, UpgradableGovernance {\r\n    using SafeMath for uint;\r\n\r\n    uint public mintCumulation;\r\n    uint public amountPerBlock;\r\n\r\n    uint public nounce;\r\n\r\n    function incNounce() public {\r\n        nounce ++;\r\n    }\r\n\r\n    // implementation of ERC20 interfaces.\r\n    string override public name;\r\n    string override public symbol;\r\n    uint8 override public decimals = 18;\r\n    uint override public totalSupply;\r\n\r\n    mapping(address => uint) override public balanceOf;\r\n    mapping(address => mapping(address => uint)) override public allowance;\r\n\r\n    function _transfer(address from, address to, uint value) internal virtual {\r\n        require(balanceOf[from] >= value, 'ERC20Token: INSUFFICIENT_BALANCE');\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        if (to == address(0)) { // burn\r\n            totalSupply = totalSupply.sub(value);\r\n        }\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external virtual override  returns (bool) {\r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external virtual override returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external virtual override returns (bool) {\r\n        require(allowance[from][msg.sender] >= value, 'ERC20Token: INSUFFICIENT_ALLOWANCE');\r\n        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    // end of implementation of ERC20\r\n    \r\n    uint lastRewardBlock;\r\n    uint totalProductivity;\r\n    uint accAmountPerShare;\r\n    struct UserInfo {\r\n        uint amount;     // How many LP tokens the user has provided.\r\n        uint rewardDebt; // Reward debt. \r\n        uint rewardEarn; // Reward earn and not minted\r\n    }\r\n\r\n    mapping(address => UserInfo) public users;\r\n\r\n    // creation of the interests token.\r\n    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint _interestsRate) UpgradableProduct() UpgradableGovernance() public {\r\n        name        = _name;\r\n        symbol      = _symbol;\r\n        decimals    = _decimals;\r\n\r\n        amountPerBlock = _interestsRate;\r\n    }\r\n\r\n    // External function call\r\n    // This function adjust how many token will be produced by each block, eg:\r\n    // changeAmountPerBlock(100)\r\n    // will set the produce rate to 100/block.\r\n    function changeInterestRatePerBlock(uint value) external virtual override requireGovernor returns (bool) {\r\n        uint old = amountPerBlock;\r\n        require(value != old, 'AMOUNT_PER_BLOCK_NO_CHANGE');\r\n\r\n        _update();\r\n        amountPerBlock = value;\r\n\r\n        emit InterestRatePerBlockChanged(old, value);\r\n        return true;\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function _update() internal virtual {\r\n        if (block.number <= lastRewardBlock) {\r\n            return;\r\n        }\r\n\r\n        if (totalProductivity == 0) {\r\n            lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        \r\n        uint256 reward = _currentReward();\r\n        balanceOf[address(this)] = balanceOf[address(this)].add(reward);\r\n        totalSupply = totalSupply.add(reward);\r\n\r\n        accAmountPerShare = accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\r\n        lastRewardBlock = block.number;\r\n    }\r\n    \r\n    function _currentReward() internal virtual view returns (uint){\r\n        uint256 multiplier = block.number.sub(lastRewardBlock);\r\n        return multiplier.mul(amountPerBlock);\r\n    }\r\n    \r\n    // Audit user's reward to be up-to-date\r\n    function _audit(address user) internal virtual {\r\n        UserInfo storage userInfo = users[user];\r\n        if (userInfo.amount > 0) {\r\n            uint pending = userInfo.amount.mul(accAmountPerShare).div(1e12).sub(userInfo.rewardDebt);\r\n            userInfo.rewardEarn = userInfo.rewardEarn.add(pending);\r\n            mintCumulation = mintCumulation.add(pending);\r\n            userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\r\n        }\r\n    }\r\n\r\n    // External function call\r\n    // This function increase user's productivity and updates the global productivity.\r\n    // the users' actual share percentage will calculated by:\r\n    // Formula:     user_productivity / global_productivity\r\n    function increaseProductivity(address user, uint value) external virtual override requireImpl returns (bool) {\r\n        require(value > 0, 'PRODUCTIVITY_VALUE_MUST_BE_GREATER_THAN_ZERO');\r\n\r\n        UserInfo storage userInfo = users[user];\r\n        _update();\r\n        _audit(user);\r\n\r\n        totalProductivity = totalProductivity.add(value);\r\n\r\n        userInfo.amount = userInfo.amount.add(value);\r\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\r\n        emit ProductivityIncreased(user, value);\r\n        return true;\r\n    }\r\n\r\n    // External function call \r\n    // This function will decreases user's productivity by value, and updates the global productivity\r\n    // it will record which block this is happenning and accumulates the area of (productivity * time)\r\n    function decreaseProductivity(address user, uint value) external virtual override requireImpl returns (bool) {\r\n        UserInfo storage userInfo = users[user];\r\n        require(value > 0 && userInfo.amount >= value, \"INSUFFICIENT_PRODUCTIVITY\");\r\n        _update();\r\n        _audit(user);\r\n        \r\n        userInfo.amount = userInfo.amount.sub(value);\r\n        userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12);\r\n        totalProductivity = totalProductivity.sub(value);\r\n\r\n        emit ProductivityDecreased(user, value);\r\n        return true;\r\n    }\r\n    \r\n    function takeWithAddress(address user) public view returns (uint) {\r\n        UserInfo storage userInfo = users[user];\r\n        uint _accAmountPerShare = accAmountPerShare;\r\n        // uint256 lpSupply = totalProductivity;\r\n        if (block.number > lastRewardBlock && totalProductivity != 0) {\r\n            uint reward = _currentReward();\r\n            _accAmountPerShare = _accAmountPerShare.add(reward.mul(1e12).div(totalProductivity));\r\n        }\r\n        return userInfo.amount.mul(_accAmountPerShare).div(1e12).sub(userInfo.rewardDebt).add(userInfo.rewardEarn);\r\n    }\r\n\r\n    function take() external override virtual view returns (uint) {\r\n        return takeWithAddress(msg.sender);\r\n    }\r\n\r\n    // Returns how much a user could earn plus the giving block number.\r\n    function takeWithBlock() external override virtual view returns (uint, uint) {\r\n        uint earn = takeWithAddress(msg.sender);\r\n        return (earn, block.number);\r\n    }\r\n\r\n\r\n    // External function call\r\n    // When user calls this function, it will calculate how many token will mint to user from his productivity * time\r\n    // Also it calculates global token supply from last time the user mint to this time.\r\n    function mint() external override virtual returns (uint) {\r\n        _update();\r\n        _audit(msg.sender);\r\n        require(users[msg.sender].rewardEarn > 0, \"NO_PRODUCTIVITY\");\r\n        uint amount = users[msg.sender].rewardEarn;\r\n        _transfer(address(this), msg.sender, users[msg.sender].rewardEarn);\r\n        users[msg.sender].rewardEarn = 0;\r\n        return amount;\r\n    }\r\n\r\n    // Returns how many productivity a user has and global has.\r\n    function getProductivity(address user) external override virtual view returns (uint, uint) {\r\n        return (users[user].amount, totalProductivity);\r\n    }\r\n\r\n    // Returns the current gorss product rate.\r\n    function interestsPerBlock() external override virtual view returns (uint) {\r\n        return accAmountPerShare;\r\n    }\r\n}"
    },
    "contracts/Tgas.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.5.16;\r\n\r\nimport './modules/ERC2917Impl.sol';\r\n\r\ncontract Tgas is ERC2917Impl(\"Tomi Swap\", \"TOMI\", 18, 40 * (10 ** 18)) {\r\n    // TOMI TEST ONLY\r\n\tconstructor() public {\r\n        totalSupply += 1000000000* 10 ** 18;\r\n        balanceOf[msg.sender] = 1000000000* 10 ** 18;   \r\n    }\r\n}"
    },
    "contracts/test/TgasTest.sol": {
      "content": "pragma solidity >=0.5.16;\r\n\r\nimport '../modules/ERC2917Impl.sol';\r\n\r\ncontract TgasTest is ERC2917Impl(\"Demax Gas\", \"DGAS\", 18, 1 * (10 ** 18)) {\r\n\r\n    constructor() public {\r\n        totalSupply += 1000000000000000* 10 ** 18;\r\n        balanceOf[msg.sender] = 1000000000000000* 10 ** 18;   \r\n    }\r\n}\r\n"
    },
    "contracts/TomiPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\nimport './libraries/Math.sol';\r\nimport './libraries/UQ112x112.sol';\r\nimport './interfaces/ITomiFactory.sol';\r\nimport './interfaces/ITgas.sol';\r\nimport './interfaces/ITomiCallee.sol';\r\nimport './interfaces/ITomiConfig.sol';\r\nimport './modules/BaseShareField.sol';\r\nimport './libraries/ConfigNames.sol';\r\n\r\ncontract TomiPair is BaseShareField {\r\n    uint256 public version = 1;\r\n    using SafeMath for uint256;\r\n    using UQ112x112 for uint224;\r\n\r\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\r\n    address public FACTORY;\r\n    address public CONFIG;\r\n    address public TGAS;\r\n    address public token0;\r\n    address public token1;\r\n\r\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\r\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\r\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\r\n\r\n    uint256 public price0CumulativeLast;\r\n    uint256 public price1CumulativeLast;\r\n\r\n    uint256 public totalReward;\r\n    uint256 public remainReward;\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) public balanceOf;\r\n    event Mint(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed from, address indexed to, uint256 value);\r\n    event MintTGAS(address indexed player, uint256 pairMint, uint256 userMint);\r\n    mapping(address => uint256) public lastMintBlock;\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1, 'Locked');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    function _mint(address to, uint256 value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Mint(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint256 value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Burn(from, address(0), value);\r\n    }\r\n    \r\n    function _mintTGAS() internal {\r\n        if(ITgas(TGAS).take() > 0) {\r\n            uint reward = ITgas(TGAS).mint();\r\n            uint devAmount = reward * ITomiConfig(CONFIG).getConfigValue(ConfigNames.DEV_PRECENT) / 10000;\r\n            address devAddress = ITomiConfig(CONFIG).dev();\r\n            _safeTransfer(TGAS, devAddress, devAmount);\r\n            remainReward = remainReward.add(reward.sub(devAmount));\r\n        }\r\n    }\r\n    \r\n    function _currentReward() internal override view returns (uint) {\r\n        uint devPercent = ITomiConfig(CONFIG).getConfigValue(ConfigNames.DEV_PRECENT);\r\n        uint pairReward = ITgas(TGAS).take().mul(10000 - devPercent).div(10000);\r\n        return mintedShare.add(remainReward).add(pairReward).sub(totalShare);\r\n    }\r\n\r\n    function getReserves()\r\n        public\r\n        view\r\n        returns (\r\n            uint112 _reserve0,\r\n            uint112 _reserve1,\r\n            uint32 _blockTimestampLast\r\n        )\r\n    {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n        _blockTimestampLast = blockTimestampLast;\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TOMI PAIR : TRANSFER_FAILED');\r\n    }\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event SwapFee(address indexed token, address indexed to, uint256 amount);\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    constructor() public {\r\n        FACTORY = msg.sender;\r\n    }\r\n\r\n    modifier onlyPlatform {\r\n        address platform = ITomiConfig(CONFIG).platform();\r\n        require(msg.sender == platform, 'TOMI PAIR : FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(\r\n        address _token0,\r\n        address _token1,\r\n        address _config,\r\n        address _tgas\r\n    ) external {\r\n        require(msg.sender == FACTORY, 'TOMI PAIR : FORBIDDEN');\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n        CONFIG = _config;\r\n        TGAS = _tgas;\r\n        _setShareToken(TGAS);\r\n    }\r\n\r\n    // update reserves and, on the first call per block, price accumulators\r\n    function _update(\r\n        uint256 balance0,\r\n        uint256 balance1,\r\n        uint112 _reserve0,\r\n        uint112 _reserve1\r\n    ) private {\r\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'TOMI PAIR : OVERFLOW');\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\r\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\r\n            // * never overflows, and + overflow is desired\r\n            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\r\n            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\r\n        }\r\n        reserve0 = uint112(balance0);\r\n        reserve1 = uint112(balance1);\r\n        blockTimestampLast = blockTimestamp;\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs // important safety checks\r\n    function mint(address to) external onlyPlatform lock returns (uint256 liquidity) {\r\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\r\n        uint256 balance0 = _balanceOf(token0, address(this));\r\n        uint256 balance1 = _balanceOf(token1, address(this));\r\n        uint256 amount0 = balance0.sub(_reserve0);\r\n        uint256 amount1 = balance1.sub(_reserve1);\r\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        if (_totalSupply == 0) {\r\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\r\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\r\n        }\r\n        require(liquidity > 0, 'TOMI PAIR : INSUFFICIENT_LIQUIDITY_MINTED');\r\n        _mint(to, liquidity);\r\n        _mintTGAS();\r\n        _increaseProductivity(to, liquidity);\r\n        lastMintBlock[to] = block.number;\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        emit Mint(msg.sender, amount0, amount1);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs // important safety checks\r\n    function burn(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external onlyPlatform lock returns (uint256 amount0, uint256 amount1) {\r\n        require(\r\n            block.number >=\r\n                lastMintBlock[from] + ITomiConfig(CONFIG).getConfigValue(ConfigNames.REMOVE_LIQUIDITY_DURATION),\r\n            'TOMI PLATFORM : REMOVE LIQUIDITY DURATION FAIL'\r\n        );\r\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        uint256 balance0 = _balanceOf(_token0, address(this));\r\n        uint256 balance1 = _balanceOf(_token1, address(this));\r\n        require(balanceOf[from] >= amount, 'TOMI PAIR : INSUFFICIENT_LIQUIDITY_AMOUNT');\r\n\r\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        amount0 = amount.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\r\n        amount1 = amount.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\r\n        require(amount0 > 0 && amount1 > 0, 'TOMI PAIR : INSUFFICIENT_LIQUIDITY_BURNED');\r\n        _burn(from, amount);\r\n        _mintTGAS();\r\n        _decreaseProductivity(from, amount);\r\n\r\n        _safeTransfer(_token0, to, amount0);\r\n        _safeTransfer(_token1, to, amount1);\r\n        balance0 = _balanceOf(_token0, address(this));\r\n        balance1 = _balanceOf(_token1, address(this));\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n\r\n        emit Burn(msg.sender, amount0, amount1, to);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs // important safety checks\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external onlyPlatform lock {\r\n        require(amount0Out > 0 || amount1Out > 0, 'TOMI PAIR : INSUFFICIENT_OUTPUT_AMOUNT');\r\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\r\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'TOMI PAIR :  INSUFFICIENT_LIQUIDITY');\r\n        uint256 balance0;\r\n        uint256 balance1;\r\n        {\r\n            address _token0 = token0;\r\n            address _token1 = token1;\r\n            require(to != _token0 && to != _token1, 'TOMI PAIR : INVALID_TO');\r\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);\r\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);\r\n            if (data.length > 0) ITomiCallee(to).tomiCall(msg.sender, amount0Out, amount1Out, data);\r\n            balance0 = _balanceOf(_token0, address(this));\r\n            balance1 = _balanceOf(_token1, address(this));\r\n        }\r\n        uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\r\n        uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\r\n        uint256 _amount0Out = amount0Out;\r\n        uint256 _amount1Out = amount1Out;\r\n        require(amount0In > 0 || amount1In > 0, 'TOMI PAIR : INSUFFICIENT_INPUT_AMOUNT');\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        emit Swap(msg.sender, amount0In, amount1In, _amount0Out, _amount1Out, to);\r\n    }\r\n\r\n    function swapFee(\r\n        uint256 amount,\r\n        address token,\r\n        address to\r\n    ) external onlyPlatform {\r\n        if (amount == 0 || token == to) return;\r\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves();\r\n        require(to != token0 && to != token1, 'TOMI PAIR : INVALID_TO');\r\n        _safeTransfer(token, to, amount);\r\n        uint256 balance0 = _balanceOf(token0, address(this));\r\n        uint256 balance1 = _balanceOf(token1, address(this));\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        emit SwapFee(token, to , amount);\r\n    }\r\n\r\n    function queryReward() external view returns (uint256 rewardAmount, uint256 blockNumber) {\r\n        rewardAmount = _takeWithAddress(msg.sender);\r\n        blockNumber = block.number;\r\n    }\r\n\r\n    function mintReward() external lock returns (uint256 userReward) {\r\n        _mintTGAS();\r\n        userReward = _mint(msg.sender);\r\n        remainReward = remainReward.sub(userReward);\r\n        emit MintTGAS(msg.sender, remainReward, userReward);\r\n    }\r\n\r\n    function getTGASReserve() public view returns (uint256) {\r\n        return _balanceOf(TGAS, address(this));\r\n    }\r\n\r\n    function _balanceOf(address token, address owner) internal view returns (uint256) {\r\n        if (token == TGAS && owner == address(this)) {\r\n            return IERC20(token).balanceOf(owner).sub(remainReward);\r\n        } else {\r\n            return IERC20(token).balanceOf(owner);\r\n        }\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() external lock {\r\n        _update(_balanceOf(token0, address(this)), _balanceOf(token1, address(this)), reserve0, reserve1);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\n// a library for performing various math operations\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant Q112 = 2**112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112; // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}"
    },
    "contracts/interfaces/ITomiCallee.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface ITomiCallee {\r\n    function tomiCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}"
    },
    "contracts/TomiConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\nimport './libraries/ConfigNames.sol';\r\nimport './libraries/TransferHelper.sol';\r\nimport './modules/TokenRegistry.sol';\r\nimport './modules/Ownable.sol';\r\n\r\ncontract TomiConfig is TokenRegistry, Ownable {\r\n    uint public version = 1;\r\n    event ConfigValueChanged(bytes32 _name, uint _old, uint _value);\r\n\r\n    struct Config {\r\n        uint minValue;\r\n        uint maxValue;\r\n        uint maxSpan;\r\n        uint value;\r\n        uint enable;  // 0:disable, 1: enable\r\n    }\r\n\r\n    mapping(bytes32 => Config) public configs;\r\n    address public tgas;                                // TGAS contract address\r\n    address public platform;      \r\n    address public dev;                         \r\n    uint public constant PERCENT_DENOMINATOR = 10000;\r\n    uint public constant TGAS_DECIMAL = 10 ** 18;\r\n    address[] public defaultListTokens;\r\n\r\n    modifier onlyPlatform() {\r\n        require(msg.sender == platform, 'TomiConfig: ONLY_PLATFORM');\r\n        _;\r\n    }\r\n\r\n    constructor()  public {\r\n        _initConfig(ConfigNames.PRODUCE_TGAS_RATE, 1 * TGAS_DECIMAL, 120 * TGAS_DECIMAL, 10 * TGAS_DECIMAL, 40 * TGAS_DECIMAL);\r\n        _initConfig(ConfigNames.SWAP_FEE_PERCENT, 5,30,5,30);\r\n        _initConfig(ConfigNames.LIST_TGAS_AMOUNT, 0, 100000 * TGAS_DECIMAL, 1000 * TGAS_DECIMAL, 0);\r\n        _initConfig(ConfigNames.UNSTAKE_DURATION, 17280, 17280*7, 17280, 17280);\r\n        _initConfig(ConfigNames.REMOVE_LIQUIDITY_DURATION, 0, 17280*7, 17280, 0);\r\n        _initConfig(ConfigNames.TOKEN_TO_TGAS_PAIR_MIN_PERCENT, 20, 500, 10, 100);\r\n        _initConfig(ConfigNames.LIST_TOKEN_FAILURE_BURN_PRECENT, 100, 5000, 500, 1000);\r\n        _initConfig(ConfigNames.LIST_TOKEN_SUCCESS_BURN_PRECENT, 1000, 5000, 500, 5000);\r\n        _initConfig(ConfigNames.PROPOSAL_TGAS_AMOUNT, 100 * TGAS_DECIMAL, 10000 * TGAS_DECIMAL, 100 * TGAS_DECIMAL, 100 * TGAS_DECIMAL);\r\n        _initConfig(ConfigNames.VOTE_DURATION, 17280, 17280*7, 17280, 17280);\r\n        _initConfig(ConfigNames.VOTE_REWARD_PERCENT, 0, 1000, 100, 500);\r\n        _initConfig(ConfigNames.TOKEN_PENGDING_SWITCH, 0, 1, 1, 1);  // 0:off, 1:on\r\n        _initConfig(ConfigNames.TOKEN_PENGDING_TIME, 0, 100*17280, 10*17280, 100*17280);\r\n        _initConfig(ConfigNames.LIST_TOKEN_SWITCH, 0, 1, 1, 0);  // 0:off, 1:on\r\n        _initConfig(ConfigNames.DEV_PRECENT, 1000, 1000, 1000, 1000);\r\n\r\n                _initConfig(ConfigNames.DEV_PRECENT, 1000, 1000, 1000, 1000);\r\n\r\n        _initConfig(ConfigNames.FEE_FUNDME_REWARD_PERCENT, 833, 833, 833, 833);  \r\n        _initConfig(ConfigNames.FEE_LOTTERY_REWARD_PERCENT, 833, 833, 833, 833);\r\n    }\r\n\r\n    function _initConfig(bytes32 _name, uint _minValue, uint _maxValue, uint _maxSpan, uint _value) internal {\r\n        Config storage config = configs[_name];\r\n        config.minValue = _minValue;\r\n        config.maxValue = _maxValue;\r\n        config.maxSpan = _maxSpan;\r\n        config.value = _value;\r\n        config.enable = 1;\r\n    }\r\n\r\n    function initialize(\r\n        address _tgas,\r\n        address _governor,\r\n        address _platform,\r\n        address _dev,\r\n        address[] memory _listTokens) public onlyOwner {\r\n        require(_tgas != address(0), \"TomiConfig: ZERO ADDRESS\");\r\n        tgas = _tgas;\r\n        platform = _platform;\r\n        dev = _dev;\r\n        for(uint i = 0 ; i < _listTokens.length; i++){\r\n            _updateToken(_listTokens[i], OPENED);\r\n            defaultListTokens.push(_listTokens[i]);\r\n        }\r\n        initGovernorAddress(_governor);\r\n    }\r\n\r\n    function modifyGovernor(address _new) public onlyOwner {\r\n        _changeGovernor(_new);\r\n    }\r\n\r\n    function modifyDev(address _new) public {\r\n        require(msg.sender == dev, 'TomiConfig: FORBIDDEN');\r\n        dev = _new;\r\n    }\r\n\r\n    function changeConfig(bytes32 _name, uint _minValue, uint _maxValue, uint _maxSpan, uint _value) external onlyOwner returns (bool) {\r\n        _initConfig(_name, _minValue, _maxValue, _maxSpan, _value);\r\n        return true;\r\n    }\r\n\r\n    function getConfig(bytes32 _name) external view returns (uint minValue, uint maxValue, uint maxSpan, uint value, uint enable) {\r\n        Config memory config = configs[_name];\r\n        minValue = config.minValue;\r\n        maxValue = config.maxValue;\r\n        maxSpan = config.maxSpan;\r\n        value = config.value;\r\n        enable = config.enable;\r\n    }\r\n    \r\n    function getConfigValue(bytes32 _name) public view returns (uint) {\r\n        return configs[_name].value;\r\n    }\r\n\r\n    function changeConfigValue(bytes32 _name, uint _value) external onlyGovernor returns (bool) {\r\n        Config storage config = configs[_name];\r\n        require(config.enable == 1, \"TomiConfig: DISABLE\");\r\n        require(_value <= config.maxValue && _value >= config.minValue, \"TomiConfig: OVERFLOW\");\r\n        uint old = config.value;\r\n        uint span = _value >= old ? (_value - old) : (old - _value);\r\n        require(span <= config.maxSpan, \"TomiConfig: EXCEED MAX ADJUST SPAN\");\r\n        config.value = _value;\r\n        emit ConfigValueChanged(_name, old, _value);\r\n        return true;\r\n    }\r\n\r\n    function checkToken(address _token) public view returns(bool) {\r\n        if (getConfigValue(ConfigNames.LIST_TOKEN_SWITCH) == 0) {\r\n            return true;\r\n        }\r\n        if (tokenStatus[_token] == OPENED) {\r\n            return true;\r\n        } else if (tokenStatus[_token] == PENDING ) {\r\n            if (getConfigValue(ConfigNames.TOKEN_PENGDING_SWITCH) == 1 && block.number > publishTime[_token] + getConfigValue(ConfigNames.TOKEN_PENGDING_TIME)) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function checkPair(address tokenA, address tokenB) external view returns (bool) {\r\n        if (checkToken(tokenA) && checkToken(tokenB)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getDefaultListTokens() external view returns (address[] memory) {\r\n        address[] memory res = new address[](defaultListTokens.length);\r\n        for (uint i; i < defaultListTokens.length; i++) {\r\n            res[i] = defaultListTokens[i];\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function addToken(address _token) external onlyPlatform returns (bool) {\r\n        if(getConfigValue(ConfigNames.LIST_TOKEN_SWITCH) == 0) {\r\n            if(tokenStatus[_token] != OPENED) {\r\n                _updateToken(_token, OPENED);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n}"
    },
    "contracts/modules/TokenRegistry.sol": {
      "content": "pragma solidity >=0.5.16;\r\n\r\nimport './Governable.sol';\r\n\r\n/**\r\n    Business Process\r\n    step 1. publishToken\r\n    step 2. addToken or removeToken\r\n */\r\n\r\ncontract TokenRegistry is Governable {\r\n    mapping (address => uint) public tokenStatus;\r\n    mapping (address => uint) public publishTime;\r\n    uint public tokenCount;\r\n    address[] public tokenList;\r\n    uint public constant NONE = 0;\r\n    uint public constant REGISTERED = 1;\r\n    uint public constant PENDING = 2;\r\n    uint public constant OPENED = 3;\r\n    uint public constant CLOSED = 4;\r\n\r\n    event TokenStatusChanged(address indexed _token, uint _status, uint _block);\r\n\r\n    function registryToken(address _token) external onlyGovernor returns (bool) {\r\n        return _updateToken(_token, REGISTERED);\r\n    }\r\n\r\n    function publishToken(address _token) external onlyGovernor returns (bool) {\r\n        publishTime[_token] = block.number;\r\n        return _updateToken(_token, PENDING);\r\n    }\r\n\r\n    function updateToken(address _token, uint _status) external onlyGovernor returns (bool) {\r\n        return _updateToken(_token, _status);\r\n    }\r\n\r\n    function validTokens() external view returns (address[] memory) {\r\n        uint count;\r\n        for (uint i; i < tokenList.length; i++) {\r\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\r\n                count++;\r\n            }\r\n        }\r\n        address[] memory res = new address[](count);\r\n        uint index = 0;\r\n        for (uint i; i < tokenList.length; i++) {\r\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\r\n                res[index] = tokenList[i];\r\n                index++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function iterateValidTokens(uint _start, uint _end) external view returns (address[] memory) {\r\n        require(_end <= tokenList.length, \"TokenRegistry: OVERFLOW\");\r\n        require(_start <= _end && _start >= 0 && _end >= 0, \"TokenRegistry: INVAID_PARAMTERS\");\r\n        uint count;\r\n        for (uint i = _start; i < _end; i++) {\r\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\r\n                count++;\r\n            }\r\n        }\r\n        address[] memory res = new address[](count);\r\n        uint index = 0;\r\n        for (uint i = _start; i < _end; i++) {\r\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\r\n                res[index] = tokenList[i];\r\n                index++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function _updateToken(address _token, uint _status) internal returns (bool) {\r\n        require(_token != address(0), 'TokenRegistry: INVALID_TOKEN');\r\n        require(tokenStatus[_token] != _status, 'TokenRegistry: TOKEN_STATUS_NO_CHANGE');\r\n        if (tokenStatus[_token] == NONE) {\r\n            tokenCount++;\r\n            require(tokenCount <= uint(-1), 'TokenRegistry: OVERFLOW');\r\n            tokenList.push(_token);\r\n        }\r\n        tokenStatus[_token] = _status;\r\n        emit TokenStatusChanged(_token, _status, block.number);\r\n        return true;\r\n    }\r\n\r\n}"
    },
    "contracts/modules/Governable.sol": {
      "content": "pragma solidity >=0.5.16;\r\n\r\ncontract Governable {\r\n    address public governor;\r\n\r\n    event ChangeGovernor(address indexed _old, address indexed _new);\r\n\r\n    modifier onlyGovernor() {\r\n        require(msg.sender == governor, 'Governable: FORBIDDEN');\r\n        _;\r\n    }\r\n\r\n    // called after deployment\r\n    function initGovernorAddress(address _governor) internal {\r\n        require(_governor != address(0), 'Governable: INPUT_ADDRESS_IS_ZERO');\r\n        governor = _governor;\r\n    }\r\n\r\n    function changeGovernor(address _new) public onlyGovernor {\r\n        _changeGovernor(_new);\r\n    }\r\n\r\n    function _changeGovernor(address _new) internal {\r\n        require(_new != address(0), 'Governable: INVALID_ADDRESS');\r\n        require(_new != governor, 'Governable: NO_CHANGE');\r\n        address old = governor;\r\n        governor = _new;\r\n        emit ChangeGovernor(old, _new);\r\n    }\r\n\r\n}"
    },
    "contracts/TomiFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.6;\r\n\r\nimport './TomiPair.sol';\r\nimport './interfaces/ITomiConfig.sol';\r\n\r\ncontract TomiFactory {\r\n    uint256 public version = 1;\r\n    address public TGAS;\r\n    address public CONFIG;\r\n    address public owner;\r\n    mapping(address => mapping(address => address)) public getPair;\r\n    mapping(address => bool) public isPair;\r\n    address[] public allPairs;\r\n\r\n    mapping(address => address[]) public playerPairs;\r\n    mapping(address => mapping(address => bool)) isAddPlayerPair;\r\n\r\n    bytes32 public contractCodeHash;\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\r\n\r\n    constructor(address _TGAS, address _CONFIG) public {\r\n        TGAS = _TGAS;\r\n        CONFIG = _CONFIG;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function updateConfig(address _CONFIG) external {\r\n        require(msg.sender == owner, 'TOMI FACTORY: PERMISSION');\r\n        CONFIG = _CONFIG;\r\n        for(uint i = 0; i < allPairs.length; i ++) {\r\n            TomiPair(allPairs[i]).initialize(TomiPair(allPairs[i]).token0(), TomiPair(allPairs[i]).token1(), _CONFIG, TGAS);\r\n        }\r\n    }\r\n\r\n    function getPlayerPairCount(address player) external view returns (uint256) {\r\n        address[] storage existAddress = playerPairs[player];\r\n        if (existAddress.length == 0) return 0;\r\n        return existAddress.length;\r\n    }\r\n\r\n    function addPlayerPair(address _player, address _pair) external returns (bool) {\r\n        require(msg.sender == ITomiConfig(CONFIG).platform(), 'TOMI FACTORY: PERMISSION');\r\n        if (isAddPlayerPair[_player][_pair] == false) {\r\n            isAddPlayerPair[_player][_pair] = true;\r\n            playerPairs[_player].push(_pair);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function allPairsLength() external view returns (uint256) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair) {\r\n        require(msg.sender == ITomiConfig(CONFIG).platform(), 'TOMI FACTORY: PERMISSION');\r\n        require(tokenA != tokenB, 'TOMI FACTORY: IDENTICAL_ADDRESSES');\r\n        require(\r\n            ITomiConfig(CONFIG).checkToken(tokenA) && ITomiConfig(CONFIG).checkToken(tokenB),\r\n            'TOMI FACTORY: NOT LIST'\r\n        );\r\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'TOMI FACTORY: ZERO_ADDRESS');\r\n        require(getPair[token0][token1] == address(0), 'TOMI FACTORY: PAIR_EXISTS'); // single check is sufficient\r\n        bytes memory bytecode = type(TomiPair).creationCode;\r\n        if (uint256(contractCodeHash) == 0) {\r\n            contractCodeHash = keccak256(bytecode);\r\n        }\r\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n        assembly {\r\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        isPair[pair] = true;\r\n        TomiPair(pair).initialize(token0, token1, CONFIG, TGAS);\r\n        getPair[token0][token1] = pair;\r\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\r\n        allPairs.push(pair);\r\n        emit PairCreated(token0, token1, pair, allPairs.length);\r\n    }\r\n}"
    },
    "contracts/modules/ERC20Token.sol": {
      "content": "pragma solidity >=0.5.16;\r\n\r\nimport '../libraries/SafeMath.sol';\r\n\r\ncontract ERC20Token {\r\n    using SafeMath for uint;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    uint public totalSupply;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        require(balanceOf[from] >= value, 'ERC20Token: INSUFFICIENT_BALANCE');\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        if (to == address(0)) { // burn\r\n            totalSupply = totalSupply.sub(value);\r\n        }\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external returns (bool) {\r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool) {\r\n        require(allowance[from][msg.sender] >= value, 'ERC20Token: INSUFFICIENT_ALLOWANCE');\r\n        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/test/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.5.16;\r\n\r\nimport '../modules/ERC20Token.sol';\r\n\r\ncontract ERC20 is ERC20Token {\r\n    constructor(uint _totalSupply, string memory _name, string memory _symbol) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        totalSupply = _totalSupply;\r\n        balanceOf[msg.sender] = totalSupply;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}